% FRE6811_Lecture_2

% Define knitr options
% !Rnw weave = knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=4, fig.height=4)
options(width=60, dev='pdf')
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% amsmath package for math symbols
% \usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE6811_bib.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text footnotesize
\renewcommand\UrlFont{\footnotesize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape,bg=red,fg=red}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[FRE6811 Lecture\#3]{FRE6811 Financial Software Laboratory}
\subtitle{Lecture\#3, Spring 2014}
% \subject{Getting Started With R}
\institute[NYU Polytechnic]{NYU Polytechnic School of Engineering}
\titlegraphic{\includegraphics[scale=0.8]{engineering_long_color}}
\author{Jerzy Pawlowski}
% \email{jp3900@poly.edu}
\date{February 10, 2014}
% \date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle


%%%%%%%%%%%%%%%
% \begin{frame}[t]{Outline}
% You might wish to add the option [pausesections]
%   \tableofcontents
% \end{frame}


%%%%%%%%%%%%%%%
\section{Operators}


%%%%%%%%%%%%%%%
\subsection{Logical Operators}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      $R$ has the following logical operators:
      \begin{itemize}
        \item '\texttt{<}' less than,
        \item '\texttt{<=}' less than or equal to,
        \item '\texttt{>}' greater than,
        \item '\texttt{>=}' greater than or equal to,
        \item '\texttt{==}' exactly equal to,
        \item '\texttt{!=}' not equal to,
        \item '\texttt{!x}' Not \texttt{x},
        \item '\texttt{x \& y}' \texttt{x} AND \texttt{y},
        \item '\texttt{x | y}' \texttt{x} OR \texttt{y},
      \end{itemize}
      These operators are applied to vectors element-wise,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
TRUE | FALSE
TRUE | NA
v.var1 <- c(2, 4, 6)
v.var1 < 5
(v.var1 < 5) & (v.var1 > 3)
v.var1[(v.var1 < 5) & (v.var1 > 3)]
v.var2 <- c(-10, 0, 10)
v.var1 < v.var2
c(FALSE, TRUE, FALSE) & c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, FALSE) | c(TRUE, TRUE, FALSE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Long Form Logical Operators}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      $R$ also has two long form logical operators:
      \begin{itemize}
        \item '\texttt{x \&\& y}' \texttt{x} AND \texttt{y},
        \item '\texttt{x || y}' \texttt{x} OR \texttt{y},
      \end{itemize}
      These operators differ from the short form operators in two ways:
      \begin{itemize}
        \item They only evaluate the first vector elements,
        \item They short-circuit (stop evaluation as soon as the expression is determined),
      \end{itemize}
      {\color{red}{Rule of Thumb}}
      \begin{itemize}
        \item Use '\texttt{\&\&}' and '\texttt{||}' in if-clauses,
      \end{itemize}
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
c(FALSE, TRUE, FALSE) && c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, FALSE) || c(TRUE, TRUE, FALSE)
FuncTrue = function() {cat("FuncTrue\t"); TRUE}
FuncFalse = function() {cat("FuncFalse\t"); FALSE}
FuncTrue() | FuncFalse()
FuncTrue() || FuncFalse()  # FuncFalse() isn't evaluated at all!
v.var <- c(2, 4, 6)
# works (does nothing) using '&&'
if (is.matrix(v.var) && (v.var[2, 3] > 0)) {
  v.var[2, 3] <- 1
}
# no short-circuit so fails (throws an error)
if (is.matrix(v.var) & (v.var[2, 3] > 0)) {
  v.var[2, 3] <- 1
}
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Control Structures}


%%%%%%%%%%%%%%%
\subsection{'\texttt{if}' statements}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      $R$ has the familiar '\texttt{if() \{...\} else \{...\}}' statement to control execution flow depending on logical conditions,
      \vskip1ex
      The logical conditions must be either a logical or numeric type, otherwise an error is thrown,
      \vskip1ex
      The '\texttt{else}' statement can also be omitted,
      \vskip1ex
      '\texttt{if}' statements can be nested using multiple '\texttt{else if}' statements,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
n.var1 <- -1
if (n.var1) {  # positive numbers are TRUE, otherwise FALSE
  n.var2 <- 4
} else if (n.var1 == 0) {  # 'else if' together on same line
  n.var2 <- 0
} else {  # keep 'else' together with curly braces
  n.var2 <- -4
}
n.var2
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Function \texttt{ifelse()}}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      $R$ also has an \texttt{ifelse()} function that controls execution but it accepts and returns vectors,
        <<func_ifelse,echo=2:30,tidy=FALSE,fig.show='hide'>>=
rm(list=ls())
# create two vectors
v.var1 <- sin(0.25*pi*1:10)
v.var2 <- cos(0.25*pi*1:10)
# create third vector using 'ifelse'
v.var3 <- ifelse(v.var1 > v.var2, v.var1, 
                 v.var2)
# cbind all three together
v.var4 <- cbind(v.var1, v.var2, v.var3)

# set plotting parameters
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), 
    cex.lab=0.8, cex.axis=0.8, cex.main=0.8, 
    cex.sub=0.5)
# plot matrix
matplot(v.var4, type="l", lty="solid", 
        col=c("green", "blue", "red"), 
        lwd=c(2, 2, 2), xlab="", ylab="")
# add legend
legend(x="bottomright", legend=colnames(v.var4), 
       title="", inset=0.05, cex=0.8, lwd=2, 
       lty=c(1, 1, 1), col=c("green", "blue", "red"))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/func_ifelse}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Iteration Using '\texttt{for}' and '\texttt{while}' Loops}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The '\texttt{for() \{...\}}' statement iterates over elements of a vector or list,
      \vskip1ex
      $R$ also has a '\texttt{while() \{...\}}' loop,
      \vskip1ex
      '\texttt{while}' loops start by testing their logical condition, and they repeat executing the loop body until that condition is \texttt{FALSE},
      \vskip1ex
      But '\texttt{while}' loops risk producing infinite loops if not written
properly, so \alert{Use Them With Care!}
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
my.colors <- list("red", "white", "blue")
for (some.color in my.colors) {  # loop over list
  print(some.color)
}
for (some.index in 1:3) {  # loop over vector
  print(my.colors[[some.index]])
}

some.index <- 1  # 'while' loops need initialization
while (some.index < 4) {  # while loop
  print(my.colors[[some.index]])
  some.index <- some.index + 1
}
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Fibonacci Sequence Using '\texttt{for}' Loop}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The \emph{Fibonacci} sequence of integers is defined by the recurrence relation:
      \begin{displaymath}
        F_{n} = F_{n-1} + F_{n-2},
      \end{displaymath}
      \begin{displaymath}
        F_{1} = 1, F_{2} = 1,
      \end{displaymath}
      \begin{displaymath}
        F_{n} = 0, 1, 1, 2, 3, 5, 8, 13, \ldots
      \end{displaymath}
      The \emph{Fibonacci} sequence was invented by \emph{Indian} mathematicians, and later described by \emph{Fibonacci} in his famous treatise \emph{Liber Abaci},
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
fib.seq <- c()  # create empty vector
fib.seq[1] <- 1  # initialize
fib.seq[2] <- 1  # initialize
for (i in 3:10) {  # perform recurrence loop
  fib.seq[i] <- fib.seq[i-1] + fib.seq[i-2]
}  # end for
fib.seq
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Simulation Using '\texttt{while}' Loops}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      '\texttt{while}' loops are often used in simulations, when the number of required loops is unknown in advance,
      \vskip1ex
      Below is an example of a simulation of random prices hitting a barrier level,
        <<rand_while,echo=7:30,fig.show='hide'>>=
# set plot paramaters - margins and font scale
par(oma=c(1, 1, 1, 1))  # set outer margins
par(mgp=c(2, 1, 0))  # set axis title and labels
par(mar=c(5, 1, 1, 1))  # set plot margins
par(cex.lab=0.8,  # set font scales
    cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
set.seed(1121)  # for reproducibility
max.simu <- 1000  # max simulation trials
v.simu <- 0*1:max.simu  # initialize trials
barrier.level <- 20  # barrier level
v.simu[1] <- rnorm(1)  # first simulation value
sim.index <- 2  # initialize simulation index
while ((sim.index <= max.simu) && 
         (v.simu[sim.index - 1] < barrier.level)) {
  v.simu[sim.index] <- v.simu[sim.index - 1] + rnorm(1)
  sim.index <- sim.index + 1
}  # end while
if (sim.index <= max.simu) {  # fill zero prices
  v.simu[sim.index:max.simu] <- v.simu[sim.index - 1]
}
# create daily time series starting 2011
ts.var <- ts(data=v.simu, frequency=365, start=c(2011, 1))
plot(ts.var, type="l", col="black",  # perform plot
     lty="solid", xlab="", ylab="")
abline(h=barrier.level, lwd=2, col="red")  # add horizontal line
title(main="Random Prices", line=0)  # add title
      @

    \column{0.5\textwidth}
      \vspace{-2em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/rand_while}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Functions}


%%%%%%%%%%%%%%%
\subsection{The Super-assignment Operator "\texttt{<<-}"}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The standard assignment operator "\texttt{<-}" operates on a \emph{local} variable in the \emph{evaluation} environment,
      \vskip1ex
      The super-assignment operator "\texttt{<<-}" modifies or creates a variable in the \emph{enclosing} environment in which the function was \emph{defined} (\emph{lexical} scoping),
      \vskip1ex
      If the function was \emph{defined} in the \emph{global} environment then that's the function's \emph{enclosing} environment and the "\texttt{<<-}" operator operates on variables in the \emph{global} environment,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
n.globvar <- 1  # define a global variable
MyFunc <- function() {  # function for exploring scope
  cat('this is the global n.globvar:\t', n.globvar, '\n')
  n.globvar <- 10  # define local 'n.globvar' variable
  n.globvar <<- 2  # re-define the global variable
  cat('this is a local n.globvar:\t', n.globvar, '\n')
}  # end MyFunc
MyFunc()
n.globvar  # the global variable
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Recursive Function for Calculating Fibonacci Sequence}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \emph{Recursive} functions call themselves in their own body, 
      \vskip1ex
      The \emph{Fibonacci} sequence of integers is defined by the recurrence relation:
      \begin{displaymath}
        F_{n} = F_{n-1} + F_{n-2},
      \end{displaymath}
      \begin{displaymath}
        F_{1} = 1, F_{2} = 1,
      \end{displaymath}
      \begin{displaymath}
        F_{n} = 0, 1, 1, 2, 3, 5, 8, 13, \ldots
      \end{displaymath}
      The \emph{Fibonacci} sequence was invented by \emph{Indian} mathematicians, and later described by \emph{Fibonacci} in his famous treatise \emph{Liber Abaci},
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
FibRec <- function(n.num) {
  if (n.num > 2) {
    fib.seq <- FibRec(n.num-1)  # recursion
    c(fib.seq, sum(tail(fib.seq, 2)))  # return this
  } else {
    c(1, 1)  # initialize and return
  }
}  # end FibRec
FibRec(10)
tail(FibRec(10), 2)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Recursive\hskip0.5em\secname\hskip0.5em with '\texttt{...}' Argument}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \emph{Recursive} functions can also accept the '\texttt{...}' argument, 
    \column{0.7\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
SumDots <- function(n.var, ...) {  # define recursive function
# returns the sum of its argument list
  if (length(list(...)) == 0) {
    return(n.var)  # just one argument left
  } else {
    n.var + SumDots(...)  # sum remaining arguments
  }
}  # end SumDots
SumDots(1, 2, 3, 4)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\secname\hskip0.5em as First Class Objects}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Functions in $R$ are \emph{first class objects}, which means they can be treated like any other $R$ object:
      \begin{itemize}
        \item Functions can be passed as arguments to other functions,
        \item Functions can be nested (defined inside other functions),
        \item Functions can return functions as their return value,
      \end{itemize}
      \emph{Higher-order} functions are $R$ functions that either take a function as input or return a function as output,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
FuncStat <- function(FuncArg) {  # function is input
# calculates statistic on random numbers
  set.seed(1)
  FuncArg(runif(1e4))  # apply the function name
}  # end FuncStat
FuncStat(mean)
FuncStat(sd)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Functionals with '\texttt{...}' Argument}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \emph{Functionals} are functions that accept a function as its input argument,
      \vskip1ex
      The '\texttt{...}' argument in \emph{functionals} can be used to pass additional arguments to the function being called by the \emph{functional},
    \column{0.7\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
FuncDots <- function(FuncIn, ...) {
# functional accepts function and additional '...' arguments
  FuncIn(...)  # apply input function to '...' arguments
}  # end FuncDots
FuncDots(sum, 1, 2, 3)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{apply()}\hskip0.5em\secname}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      An important example of \emph{functionals} are the \texttt{apply()} functions,
      \vskip1ex
      The function \texttt{apply()} returns the result of applying a function to the rows or columns of an array or matrix,
      \vskip1ex
      If \texttt{MARGIN=1} then the function will be applied over the matrix \emph{rows,}
      \vskip1ex
      If \texttt{MARGIN=2} then the function will be applied over the matrix \emph{columns},
      \vskip1ex
      The function \texttt{apply()} can replace '\texttt{for}' loops,
    \column{0.7\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
args(apply)  # get list of arguments
m.var <- matrix(6:1, nrow=2, ncol=3)  # create a matrix
m.var
# sum the rows and columns
row.sums <- apply(m.var, 1, sum)
col.sums <- apply(m.var, 2, sum)
m.totals <- cbind(c(sum(row.sums), row.sums), 
                  rbind(col.sums, m.var))
dimnames(m.totals) <- list(c("col.sums", "row1", "row2"), 
                           c("row.sums", "col1", "col2", "col3"))
m.totals
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{apply()} Function with '\texttt{...}' Argument}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  The '\texttt{...}' argument in \texttt{apply()} is designed to pass additional arguments to the function being called by \texttt{apply()},
  \begin{columns}[T]
    \column{0.5\textwidth}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
args(apply)  # get list of arguments
m.var <- matrix(sample(12), nrow=3, ncol=4)  # create a matrix
m.var
apply(m.var, 2, sort)  # sort matrix columns
apply(m.var, 2, sort, decreasing=TRUE)  # sort decreasing order
      @
    \column{0.5\textwidth}
        <<echo=1:30,tidy=FALSE>>=
m.var[2, 2] <- NA  # introduce NA value
m.var
# calculate median of columns
apply(m.var, 2, median)
# calculate median of columns with na.rm=TRUE
apply(m.var, 2, median, na.rm=TRUE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Functionals with Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      $R$ allows defining functions without assigning a name to them,
      \vskip1ex
      \emph{Anonymous} functions are functions that are not assigned to a name,
      \vskip1ex
      \emph{Anonymous} functions can be passed as arguments to \emph{functionals},
    \column{0.7\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
FuncDots <- function(..., FuncIn=function(x, y, z) {x+y+z}) {
# functional accepts function and additional '...' arguments
  FuncIn(...)  # apply input function to '...' arguments
}  # end FuncDots
FuncDots(FuncIn=sum, 2, 3, 4)
FuncDots(2, 3, 4)
FuncDots(2, 3, 4, 5)
FuncDots(FuncIn=function(x, y, z) {x*y*z}, 2, 3, 4)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{apply()} Function with Anonymous Functions}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The \texttt{apply()} function combined with \emph{anonymous} functions can be used to loop over function parameters,
      \vskip1ex
  The '\texttt{...}' argument in \texttt{apply()} is designed to pass additional arguments to the function being called by \texttt{apply()},
    \column{0.7\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
ts.rets <- 100*diff(log(EuStockMarkets))[, 1]  # DAX percent returns
library("moments")  # load library"moments"
str(moment)  # get list of arguments
moment(x=ts.rets, order=3)  # the moment function
v.orders <- as.matrix(1:4)  # 4x1 matrix of moment orders
# anonymous function allows looping over function parameters
apply(X=v.orders, MARGIN=1, 
      FUN=function(n.order) {moment(x=ts.rets, order=n.order)})
# another way of passing data into moment() function
apply(X=v.orders, MARGIN=1, FUN=moment, x=ts.rets)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\secname\hskip0.5em That Return \secname}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      $R$ functions can also return a function as their value,
      \vskip1ex
      Functions returned by a function are called \emph{closures},
      \vskip1ex
      Functions that return closures can be used as \emph{function factories},
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
FuncPower <- function(n.exp) {  # wrapper function
# a power function factory
  function(n.arg) {  # anonymous closure
    n.arg^n.exp
  }
}  # end FuncPower
FuncSquare <- FuncPower(2)  # define square power
FuncSquare(4)
FuncCube <- FuncPower(3)  # define cube power
FuncCube(2)
FuncCubeRoot <- FuncPower(1/3)  # define cube root
FuncCubeRoot(8)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Mutable States}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      A \emph{mutable state} is an object that is preserved between function calls,
      \vskip1ex
      Functions that return closures can also be used for creating \emph{mutable states},
      \vskip1ex
      A function \emph{evaluation} environment is only temporary and disappears after the function returns its value,
      \vskip1ex
      But a \emph{closure} assigned to a name maintains access to the environment in which it was created,
      \vskip1ex
      Therefore the \emph{closure} maintains access to its parent function's arguments and locally defined variables,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
MuteCounter <- function() {
# counter function with mutable state
  i.count <- 0  # initialize counter
  cat('counter = ', i.count)
  function() {  # return anonymous advance function
    i.count <<- i.count + 1  # advance counter
    cat('counter = ', i.count)
  }  # end advance function
}  # end MuteCounter
CounterOne <- MuteCounter()  # create new counter
CounterOne()  # advance counter
CounterOne()  # advance counter
CounterTwo <- MuteCounter()  # create another counter
CounterTwo()  # advance counter two
CounterOne()  # advance counter one
CounterTwo()  # advance counter two
CounterOne()  # advance counter one
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Pseudo-Random Generating Function}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \emph{Mutable states} can be used to implement pseudo-random number generators,
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
RandomSeed <- function(seed) {  # seed must be an integer
# Returns pseudo-random generating function based on logistic map
# the formal argument 'seed' exists in the evaluation environment of RandomSeed
  pseudo.random <- as.numeric(paste('0.', seed, sep=''))  # initialize
  RandomVector <- function(n.rand=1) {  # assign function name for recursion
# Returns a vector of pseudo-random numbers of length n.rand
    pseudo.random <<- 4*pseudo.random*(1 - pseudo.random)  # logistic map
    if(n.rand == 1) {
      return(pseudo.random)
    } else {
      return(c(pseudo.random, RandomVector(n.rand - 1)))
    }
  }
}  # end RandomSeed

PseudoRandom <- RandomSeed(88)  # set seed
PseudoRandom(10)  #  calculate vector of 10 pseudo-random numbers
ls(environment(PseudoRandom))  # list objects in scope of PseudoRandom
      @
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Homework Assignment}
\begin{frame}[t]{\subsecname}

\begin{block}{Required}
  \begin{itemize}[]
    \item Create an $R$ script for simulating 1000 random prices using rnorm(),
    \item Use a '\texttt{while}' loop to stop the simulation if the prices first cross barrier.level1=-10, and then cross barrier.level2=10,
    \item Plot the prices and the two barrier levels,
  \end{itemize}
\end{block}
\pause

\begin{block}{Recommended}
  \begin{itemize}[]
    \item Read chapters 9, 10, 13: \fullcite{website:rintro}
  \end{itemize}
\end{block}

\end{frame}


\end{document}
