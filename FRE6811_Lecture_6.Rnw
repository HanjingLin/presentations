% FRE6811_Lecture_6

% Define knitr options
% !Rnw weave = knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=6, fig.height=5)
options(width=60, dev='pdf')
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% amsmath package for math symbols
\usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE6811_bib.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text footnotesize
\renewcommand\UrlFont{\footnotesize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape,bg=red,fg=red}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[FRE6811 Lecture\#6]{FRE6811 Financial Software Laboratory}
\subtitle{Lecture\#6, Spring 2014}
% \subject{Getting Started With R}
\institute[NYU Polytechnic]{NYU Polytechnic School of Engineering}
\titlegraphic{\includegraphics[scale=0.8]{engineering_long_color}}
\author{Jerzy Pawlowski}
% \email{jp3900@poly.edu}
\date{March 3, 2014}
% \date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle


%%%%%%%%%%%%%%%
\section{Hypothesis Testing}


%%%%%%%%%%%%%%%
\subsection{Statistical Estimators}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      A data \emph{sample} is a set of data selected from a statistical population (distribution),
      \vskip1ex
      Let $\{x_{1},\ldots ,x_{n}\}$ be a data \emph{sample} from a given distribution,
      \vskip1ex
      A \emph{statistic} is a function of a data \emph{sample}:  $f( x_{1},\ldots ,x_{n} )$,
      \vskip1ex
      A \emph{statistic} is itself a \emph{random variable},
      \vskip1ex
      A statistical \emph{estimator} is a \emph{statistic} that provides an estimate of a \emph{distribution} parameter,
      \vskip1ex
      For example:
      \begin{displaymath}
        \bar{x}=\frac{1}{n}{\sum_{i=1}^{n}x_{i}}
      \end{displaymath}
      Is an \emph{estimator} of the \emph{mean} of the \emph{distribution},
    \column{0.6\textwidth}
      \vspace{-2em}
      <<echo=4:30,tidy=FALSE>>=
rm(list=ls())
par(oma=c(1, 1, 1, 1), mgp=c(2, 0.5, 0), mar=c(5, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
set.seed(1121)  # initialize the random number generator
# sample from Standard Normal Distribution
test.samples <- rnorm(1000)

mean(test.samples)  # sample mean

sd(test.samples)  # sample standard deviation

      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Hypothesis Testing}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.45\textwidth}
      \vspace{-1em}
      \emph{Hypothesis Testing} is designed to test the validity of a \emph{null hypothesis},
      \vskip1ex
      A \emph{Hypothesis Test} consists of:
      \begin{itemize}[]
        \item a \emph{null hypothesis},
        \item a  test \emph{statistic} (based on a sample),
        \item a \emph{significance level} $\alpha$, determining whether to accept or reject the \emph{null hypothesis},
        \item a \emph{p}-value (probability of observing the value of the test statistic, assuming the null hypothesis is true),
      \end{itemize}
      If the \emph{p}-value is less than the \emph{significance level} $\alpha$, then the \emph{null hypothesis} is rejected,
      \vskip1ex
      The objective of \emph{Hypothesis Testing} is to invalidate the \emph{null hypothesis},
      \vskip1ex
      In statistics we cannot \emph{prove} that a hypothesis is TRUE; we can only conclude that it's very unlikely to be FALSE,
    \column{0.55\textwidth}
      \vspace{-2em}
      <<echo=4:30,tidy=FALSE>>=
rm(list=ls())
par(oma=c(1, 1, 1, 1), mgp=c(2, 0.5, 0), mar=c(5, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
set.seed(1121)  # initialize the random number generator
### Perform two-tailed test that sample is 
### from Standard Normal Distribution (mean=0, SD=1)
# generate vector of samples
rand.samples=rnorm(1000)
df.test <- data.frame(samples=rand.samples)
critical.value <- 2  # critical value = 2 SD
# two-tailed test significance level
signif.level <- 2*(1-pnorm(critical.value))
signif.level
# get p.values for all the samples
df.test$p.values <- sapply(df.test$samples, pnorm)
df.test$p.values <- 2*(0.5-abs(df.test$p.values-0.5))
# compare p.values to significance level
df.test$result <- df.test$p.values > signif.level
sum(!df.test$result)  # number of null rejections
# show null rejections
head(df.test[!df.test$result, ])
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Visualizing Hypothesis Testing Using Package \texttt{ggplot2}}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \vspace{-1em}
      <<hyp_test_ggp2,echo=3:30,tidy=FALSE,fig.show='hide'>>=
rm(list=ls())
par(oma=c(1, 1, 1, 1), mgp=c(2, 0.5, 0), mar=c(5, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(ggplot2)  # load ggplot2

qplot(  # simple ggplot2
    main="Standard Normal Distribution", 
    c(-4, 4), 
    stat="function", 
    fun=dnorm, 
    geom="line", 
    xlab=NULL, ylab=NULL
    ) +  # end qplot

theme(  # modify plot theme
    plot.title=element_text(vjust=-1.0), 
    plot.background=element_blank()
    ) +  # end theme

geom_vline(  # add vertical line
  aes(xintercept=c(-2.0, 2.0)), 
  colour="red", 
  linetype="dashed"
  )  # end geom_vline
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/hyp_test_ggp2}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Visualizing Hypothesis Testing Using \texttt{ggplot2} (cont)}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \vspace{-1em}
      <<hyp_test_ggp2_2,echo=3:30,tidy=FALSE,fig.show='hide'>>=
rm(list=ls())
par(oma=c(1, 1, 1, 1), mgp=c(2, 0.5, 0), mar=c(5, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
### create ggplot2 with shaded area
x.reg <- -400:400/100
df.dnorm <- data.frame(x.reg=x.reg, 
                       d.norm=dnorm(x.reg))
df.dnorm$shade <- ifelse(
                  abs(df.dnorm$x.reg) >= 2, 
                  df.dnorm$d.norm, NA)
ggplot(  # main function
  data=df.dnorm, 
  mapping=aes(x=x.reg, y=d.norm)
  ) +  # end ggplot
# plot line
  geom_line() + 
# plot shaded area
  geom_ribbon(aes(ymin=0, ymax=shade), fill="red") + 
# no axis labels
  xlab("") + ylab("") + 
# add title
  ggtitle("Standard Normal Distribution") +
# modify plot theme
  theme(
        plot.title=element_text(vjust=-1.0), 
        plot.background=element_blank()
  )  # end theme
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/hyp_test_ggp2_2}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Univariate Statistical Models}


%%%%%%%%%%%%%%%
\subsection{Shapiro-Wilk Test of Normality}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Shapiro-Wilk} test is designed to test the \emph{null hypothesis} that a sample: $\{x_{1},\ldots ,x_{n}\}$ is from a normally distributed population,
      \vskip1ex
      The test statistic is:
      \begin{displaymath}
        W= \frac {(\sum_{i=1}^{n} a_{i} x_{(i)})^2} {\sum_{i=1}^{n} (x_{i}-\bar{x})^2}
      \end{displaymath}
      Where the: $\{a_{1},\ldots ,a_{n}\}$ are proportional to the \emph{order statistics} of random variables from the normal distribution,
      \vskip1ex
      The \emph{Shapiro-Wilk} statistic follows its own distribution, and is less than or equal to one,
      \vskip1ex
      The \emph{Shapiro-Wilk} statistic is close to one for samples from normal distributions,
      \vskip1ex
      The  p-value for DAX returns is extremely small, and we conclude that the \emph{null hypothesis} is FALSE, and the DAX returns are not from a normally distributed population,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=3:30,tidy=FALSE>>=
rm(list=ls())
set.seed(1121)  # initialize the random number generator
# calculate DAX percentage returns
ts.dax <- diff(log(EuStockMarkets[, 1]))

# Shapiro-Wilk test for normal distribution
shapiro.test(rnorm(length(ts.dax)))

# Shapiro-Wilk test for DAX returns
shapiro.test(ts.dax)

# Shapiro-Wilk test for uniform distribution
shapiro.test(runif(length(ts.dax)))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Jarque-Bera Test of Normality}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Jarque-Bera} test is designed to test the \emph{null hypothesis} that a sample: $\{x_{1},\ldots ,x_{n}\}$ is from a normally distributed population,
      \vskip1ex
      The test statistic is:
      \begin{displaymath}
        JB= \frac{n}{6} (\hat{s}^2 + \frac{1}{4} (\hat{k} - 3)^2)
      \end{displaymath}
      Where the skewness and kurtosis are defined as:
      \begin{align}{\notag}
        \hat{s} = \frac{1}{n} \sum_{i=1}^{n} (\frac{x_{i}-\bar{x}}{\hat{\sigma}})^3
      &&
        \hat{k} = \frac{1}{n} \sum_{i=1}^{n} (\frac{x_{i}-\bar{x}}{\hat{\sigma}})^4
      \end{align}
      The \emph{Jarque-Bera} statistic asymptotically follows the \emph{chi-squared} distribution with two degrees of freedom,
      \vskip1ex
      The \emph{Jarque-Bera} statistic is small for samples from normal distributions,
      \vskip1ex
      The  p-value for DAX returns is extremely small, and we conclude that the \emph{null hypothesis} is FALSE, and the DAX returns are not from a normally distributed population,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<echo=2:30,tidy=FALSE>>=
ts.dax <- diff(log(EuStockMarkets[, 1]))
library(tseries)  # load package tseries

# Jarque-Bera test for normal distribution
jarque.bera.test(rnorm(length(ts.dax)))

# Jarque-Bera test for DAX returns
jarque.bera.test(ts.dax)

# Jarque-Bera test for uniform distribution
jarque.bera.test(runif(length(ts.dax)))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Autocorrelation Function}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{Autocorrelation Function} is the correlation coefficient of a time series with its lagged values:
      \begin{displaymath}
        \rho_{k} = \frac{1}{\sigma^2} {\sum_{i=k+1}^{n} (x_{i}-\bar{x})(x_{i-k}-\bar{x})}
      \end{displaymath}
      The package \texttt{forecast} contains functions for univariate time series forecasting,
        <<eustx_acf,echo=4:30,fig.height=8,eval=TRUE,tidy=FALSE,fig.show='hide'>>=
par(oma=c(1, 1, 1, 1), mgp=c(2, 0.5, 0), mar=c(5, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# calculate DAX percentage returns
ts.dax <- diff(log(EuStockMarkets[, 1]))
library(forecast)  # load forecast
par(mfrow=c(2,1))  # set plot panels
# autocorrelation from "stats"
acf(ts.dax, lag=5, xlab=NA)
# autocorrelation from "forecast"
Acf(ts.dax, lag=5, xlab=NA)
      @
      The horizontal dashed lines are the confidence intervals corresponding to the 95\% significance level,
      \vskip1ex
      The DAX time series does not have statistically significant autocorrelations,
    \column{0.5\textwidth}
      \vspace{-2em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/eustx_acf}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Filtering Time Series}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \vspace{-2.5em}
      <<dax_filter,echo=3:30,tidy=FALSE,fig.show='hide'>>=
rm(list=ls())
library(zoo)  # load zoo
library(ggplot2)  # load ggplot2
library(gridExtra)  # load gridExtra
# coerce DAX time series to zoo
zoo.dax <- as.zoo(EuStockMarkets)[, 1]
index(zoo.dax) <-  # index to class 'Dates'
  as.Date(365*(index(zoo.dax)-1970))
# filter past values only (sides=1)
dax.filt <- filter(zoo.dax, 
                   filter=rep(1/5,5), sides=1)
dax.filt <- zoo(coredata(dax.filt), 
                order.by=index(zoo.dax))
dax.filt <- merge(zoo.dax, dax.filt)
dax.filt <- na.omit(dax.filt)
colnames(dax.filt) <- c("DAX", "DAX filtered")
dax.data <- window(dax.filt, 
                   start=as.Date("1997-01-01"), 
                   end=as.Date("1998-01-01"))
autoplot(  # plot ggplot2
    dax.data, main="Filtered DAX", facets=NULL
      ) +  # end autoplot
xlab("") + ylab("") +
theme(  # modify plot theme
    legend.position=c(0.1, 0.5), 
    plot.title=element_text(vjust=-2.0), 
    plot.margin=unit(c(-0.5, 0.0, -0.5, 0.0), "cm"), 
    plot.background=element_blank(),
    axis.text.y=element_blank()
    )  # end theme
# end ggplot2
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/dax_filter}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Autocorrelation Function for Filtered Time Series}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Filtering a time series creates spurious autocorrelations,
      <<dax_filter_acf,echo=1:30,fig.height=8,tidy=FALSE,fig.show='hide'>>=
dax.diff <- na.omit(diff(log(dax.filt)))
par(mfrow=c(2,1))  # set plot panels
Acf(dax.diff[, 1], lag=20, xlab=NA, ylab=NA, 
    main="DAX")
Acf(dax.diff[, 2], lag=20, xlab=NA, ylab=NA, 
    main="DAX filtered")
      @
    \column{0.5\textwidth}
      \vspace{-2em}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/dax_filter_acf}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Partial Autocorrelation Function}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The \emph{partial autocorrelation} of lag $k$ is the autocorrelation after all the autocorrelations of lag $1,..., k-1$ have been removed,
        <<eustx_pacf,echo=2:30,fig.height=8,eval=TRUE,tidy=FALSE,fig.show='hide'>>=
par(oma=c(1, 1, 1, 1), mgp=c(2, 0.5, 0), mar=c(5, 1, 1, 1), cex.lab=0.8, cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
par(mfrow=c(2,1))  # set plot panels
# autocorrelation from "stats"
Acf(dax.diff[, 2], lag=20, xlab=NA, ylab=NA)
# autocorrelation from "forecast"
Pacf(dax.diff[, 2], lag=20, xlab=NA, ylab=NA)
      @

    \column{0.5\textwidth}
      \vspace{-2em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/eustx_pacf}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Homework Assignment}
\begin{frame}[t]{\subsecname}

\begin{block}{Required}
  \begin{itemize}[]
    \item Create a summary function called "\texttt{my.summary()}",
    \item The input is a time series object,
    \item The function should return a list object with summary information: length, dimension, colnames, object class, data type, and the first and last rows of data,
    \item Your code should test the function on a variety of possible inputs: character, matrix, ts, zoo,
    \item The function should throw an error if the input is not a time series object,
  \end{itemize}
\end{block}
\pause

\begin{block}{Recommended}
  \begin{itemize}[]
    \item \fullcite{website:ggplot2}
    \item \fullcite{website:ggplot2cook}
  \end{itemize}
\end{block}

\end{frame}

\end{document}
