% Define knitr options
% !Rnw weave = knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=4, fig.height=4)
options(width=60, dev='pdf')
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% amsmath package for math symbols
% \usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE6811_bib.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text footnotesize
\renewcommand\UrlFont{\footnotesize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape,bg=red,fg=red}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[FRE6811 Lecture\#1]{FRE6811 Financial Software Laboratory}
\subtitle{Lecture\#1, Spring 2014}
% \subject{Getting Started With R}
\institute[NYU Polytechnic]{NYU Polytechnic School of Engineering}
\titlegraphic{\includegraphics[scale=0.8]{engineering_long_color}}
\author{Jerzy Pawlowski}
% \email{jp3900@poly.edu}
\date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle


%%%%%%%%%%%%%%%
\section{Basic Operations in $R$}


%%%%%%%%%%%%%%%
\subsection{Assignment Operators}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The standard assignment operator in $R$ is "\texttt{<-}",
      \vskip1ex
      Both "\texttt{<-}" and "\texttt{=}" are valid assignment operators in $R$,
      \vskip1ex
      But they differ in \emph{scope} and  \emph{precedence} ("\texttt{<-}" has higher precedence than "\texttt{=}"),
      \vskip1ex
      The "\texttt{=}" operator is used for named arguments in function calls,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
n.var1 <- 3 - 1
n.var1
n.var1 = 3 - 1
n.var1
      @
  \end{columns}
\end{block}
\pause

\begin{block}{\color{red}{Rule of Thumb}}
  Use "\texttt{<-}" in $R$ scripts,
  \vskip1ex
  Use "\texttt{=}" in function calls.
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The $R$ Workspace}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The workspace is the current $R$ working environment, which includes all user-defined objects and the command history,
      \vskip1ex
      The function \texttt{ls()} returns names of objects in the $R$ workspace,
      \vskip1ex
      The function \texttt{rm()} removes objects from the $R$ workspace,
      \vskip1ex
      The workspace can be saved into and loaded back from an $*.RData$ file (binary file format),
      \vskip1ex
      The function \texttt{save.image()} saves the whole workspace,
      \vskip1ex
      The function \texttt{save()} saves just the selected objects,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<tidy=FALSE,prompt=TRUE>>=
n.var1 <- 3  # define new object
ls()  # list objects
save.image()  # save workspace to file .RData in cwd
rm(n.var1)  # remove object
ls()  # list objects
load(".RData")
ls()  # list objects
n.var2 <- 5  # define another object
save(n.var1, n.var2,  # save selected objects
     file="C:/jerzy/temp/my_data.RData")
rm(n.var1, n.var2)  # remove objects
ls()  # list objects
load(file="C:/jerzy/temp/my_data.RData")
ls()  # list objects
      @
  \end{columns}
\end{block}
% \pause

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em (cont.)}

\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      When you quit $R$ you'll be prompted "Save workspace image?"
      \vskip1ex
      If you answer $YES$ then the workspace will be saved into the $.RData$ file in the $cwd$,
      \vskip1ex
      When you start $R$ again, the workspace will be automatically loaded from the existing $.RData$ file,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<eval=FALSE,prompt=TRUE>>=
        q()  # quit R session
      @
  \end{columns}
\end{block}
\pause

\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{history()} displays recent commands,
      \vskip1ex
      You can also save and load the command history from a file,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<eval=FALSE,prompt=TRUE>>=
history(5)  # display last 5 commands
savehistory(file="myfile")  # default is ".Rhistory" 
loadhistory(file="myfile")  # default is ".Rhistory"
      @
  \end{columns}
\end{block}
% \pause

\end{frame}


%%%%%%%%%%%%%%%
\section{Data Structures}


%%%%%%%%%%%%%%%
\subsection{\secname\hskip0.5em in $R$}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Homogeneous data structures contain objects of the same class,
      \vskip1ex
      Heterogeneous structures can contain objects of different classes,
    \column{0.5\textwidth}
%      \vspace{-1em}
      \renewcommand\arraystretch{1.5} % scale table rows
      \renewcommand\tabcolsep{8pt} % set table column width - 6pt is default
      \centering{{\color{blue}{$R$ Data Structures}}}\\[1ex]
      \begin{tabular}{c||c|c|}
        & \text{Homogeneous} & \text{Heterogeneous} \\
        \hline
        \hline
        \text{1-dim} & Vectors & Lists \\
        \hline
        \text{2-dim} & Matrices & Data frames \\
        \hline
        \text{n-dim} & Arrays & NA \\
      \end{tabular}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Character Strings}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Strings are character objects of length one,
      \vskip1ex
      The function \texttt{paste()} converts elements to characters and concatenates them into a string,
      \vskip1ex
      The function \texttt{cat()} concatenates and writes to output,\\
      The function \texttt{cat()} is useful in user-defined functions,\\
      The recycling rule extends the length to match the longest object,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
s.var1 <- "Hello"  # define a character string
s.var2 <- "World!"  # define a character string
paste(s.var1, s.var2, sep=' ')  # concatenate
paste('a', 1:4, sep='-')  # convert, recycle and concatenate
cat(s.var1, s.var2)  # concatenate and write to output
strsplit("Hello World", split='r')  # split string
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Vectors}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{c()} combines values into a vector or a list,
      \vskip1ex
      Vectors can be indexed (subset) using vectors of:
      \begin{itemize}[]
        \item positive integers,
        \item negative integers,
        \item characters,
        \item logical vectors,
      \end{itemize}
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
v.var <- c(pi, exp(1), -digamma(1))  # define a vector
v.var
v.var[2]  # get second element
v.var[-2]  # get all elements, except the second element
v.var[c(F, T, T)]  # get second and third elements
v.var == v.var[2]  # logical vector of elements equal to the second one
v.var < 1  # logical vector of elements less than one
v.var[v.var > 1]  # get all elements greater than one
      @
  \end{columns}
\end{block}
\pause

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vectors can be multiplied and squared element by element,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=2:20,prompt=TRUE>>=
v.var <- c(pi, exp(1), -digamma(1))
v.var
2*v.var  # multiply all elements by 2
v.var^2  # square all elements
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em (cont.)}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vector elements can be assigned $names$,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
v.var <- c(pi=pi, euler=exp(1), gamma=-digamma(1))
v.var
names(v.var)  # get names of elements
v.var['euler']  # get element named 'euler'
names(v.var) <- c("pie","eulery","gammy")  # rename elements
v.var
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em of Numbers}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{seq()} returns a vector of numbers,
      \vskip1ex
      Another way of producing a vector of numbers is by using the "\texttt{:}" operator,
      \vskip1ex
      \texttt{letters} is a constant and a vector,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
seq(from=0, to=1, len=11)  # vector of decimals from 0 to 1.0
seq(from=0, to=1, by=0.1)  # vector of decimals from 0 to 1.0
0:10  # vector of integers from 0 to 10
(0:10)/10  # vector of decimals from 0 to 1.0
letters[5:10]  # vector of letters
      @
  \end{columns}
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Appending vectors,
      \vskip1ex
      The function \texttt{vector()} returns an empty vector,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
c(11, 5:10)  # append to vector
c(20:25, 5:10)  # append to vector
v.var <- vector()  # create empty vector
v.var <- vector("numeric",  # create numeric vector of zeros
                length=10)
c(v.var, 2.0)  # append to vector
c('a', letters[5:10])  # vector of letters
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lists}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Lists are a type of vector that contain elements of different classes,
      \vskip1ex
      Lists are recursive object types,
      \vskip1ex
      Lists can be indexed (subset) using:
      \begin{itemize}[]
        \item the '\texttt{[[}' operator,
        \item the '\texttt{\$}' operator (for named lists only),
      \end{itemize}
      \vskip1ex
      Partial name matching allows subsetting with partial name, as long as it can be resolved, 
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
l.var <- list(c('a', 'b'), 1:4)  # create a list
l.var
typeof(l.var)
l.var[[2]]  # get second element
l.var[[2]][3]  # get third element of second element
l.var[[c(2, 3)]]  # get third element of second element
l.var <- list(first=c('a', 'b'),  # create named list
              second=1:4)
names(l.var)
l.var$second  # get second element
l.var$s  # get second element - partial name matching
l.var$second[3]  # get third element of second element
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{$R$ Object Attributes}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      $R$ objects can have the following attributes:
      \begin{itemize}[]
        \item length,
        \item names,
        \item dimnames,
        \item dimensions,
        \item class,
        \item Other user-defined attributes/metadata,
      \end{itemize}
      \vskip1ex
      The function \texttt{attributes()} returns the attributes of an object,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
attributes(5:10)  # a simple vector has no attributes
v.var <- c(pi=pi, euler=exp(1), gamma=-digamma(1))
attributes(v.var)  # a named vector has 'names' attribute
class(attributes(v.var))  # the attribute is a list object 
length(v.var)
is.vector(v.var)  # is the object a vector?
is.vector(names(v.var))  # names are character vectors
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Type and Class of Objects}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The \texttt{type} of an  $R$ object represents how it's stored in memory,\\
      Examples of $R$ \texttt{types} are \texttt{double}, \texttt{character}, \texttt{list}, etc.
      \vskip1ex
      The \texttt{class} of an  $R$ object is an attribute used for function dispatching in S3 classes,\\
      Examples of $R$ \texttt{classes} are \texttt{character}, \texttt{numeric}, \texttt{matrix}, \texttt{factor}, \texttt{data.frame}, etc.
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
v.var <- c(pi=pi, euler=exp(1), gamma=-digamma(1))
typeof(v.var)  # get object type
class(v.var)  # get object class
typeof(names(v.var))
class(names(v.var))
v.var <- c(1:5, 'a')  # append to vector
v.var  # type coercion
class(v.var)  # get object class
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Type Coercion}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      When different objects are mixed in a vector, implicit coercion occurs so that every element in the vector is of the same class,
      \vskip1ex
      The rule is that coercion is into larger types (numeric values are coerced into character strings),
      \vskip1ex
      Objects can be explicitly coerced from one class to another using the \texttt{as.*} functions,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
c(1:3, 'a')  # implicit coercion
as.numeric(c(1:3, 'a'))  # explicit coercion
as.logical(0:3)
as.character(0:3)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Arrays and Matrices}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Arrays are vectors with a dimension attribute,
      \vskip1ex
      Matrices are two-dimensional arrays,
      \vskip1ex
      The dimension attribute of a matrix is an integer vector of length 2 (nrow, ncol),
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
m.var <- matrix(1:6, nrow=2, ncol=3)  # create a matrix
m.var  # by default matrices are constructed column-wise
class(m.var)  # matrix class
dim(m.var)  # get dimension attribute
rownames(m.var) <- c("row1", "row2")  # set the rownames attribute
colnames(m.var) <- c("col1", "col2", "col3")  # set the colnames attribute
m.var
names(m.var)  # get the names attribute
dimnames(m.var)  # get dimnames attribute
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em (cont.)}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vectors can be converted into matrices by adding a dimension attribute,
      \vskip1ex
      The attribute \texttt{dimnames} can be assigned a named list to convert into a named matrix,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE,prompt=TRUE>>=
m.var <- 1:6  # create a vector
dim(m.var) <- c(2, 3)  # convert into matrix by adding dimension attribute
dimnames(m.var) <- list('rows'=c('row1', 'row2'),  # set dimnames attribute
                        'columns'=c('col1', 'col2', 'col3'))
m.var
      @
  \end{columns}
\end{block}
\pause

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Indexing (subsetting) matrices,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=2:20,prompt=TRUE>>=
m.var <- matrix(1:6, nrow=2, ncol=3)  # create a matrix
m.var
m.var[2, ]  # get second row
m.var[c(1,2), ]  # get first and second rows
m.var[ ,3]  # get third column
m.var[ ,-2]  # remove second column
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Binding Vectors and Matrices Together}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vectors can be bound into matrices using the functions \texttt{cbind()} and \texttt{rbind()},
      \vskip1ex
      The \alert{recycling rule} allows operations on vectors of different lengths:\\
      \begin{enumerate}
        \item Vectors are scanned from left to right,
        \item Shorter vectors are extended in length by recycling their values until they match the length of longer vectors,
      \end{enumerate}
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
v.var1 <- c(1, 2, 3)
v.var2 <- c(4, 5, 6)
cbind(v.var1, v.var2)  # bind into columns
rbind(v.var1, v.var2)  # bind into rows
v.var2 <- c(4, 5, 6, 7)  # extend second vector to four elements
cbind(v.var1, v.var2)  # recycling rule applied
1:6 + c(10, 20)  # another example of recycling rule
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Factors}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Factors are vectors whose elements can have only certain values,
      \vskip1ex
      Factors are designed to describe categorical data which can only take certain values,
      \vskip1ex
      The function \texttt{factor()} converts a character vector into a factor,
      \vskip1ex
      Factors have two attributes: \texttt{class} ("\texttt{factor}") and \texttt{levels} (the allowed values),
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE,prompt=TRUE>>=
f.var <- factor(c('b', 'c',  # create factor vector
                        'd', 'a', 'c', 'b'))
class(f.var)  # get object class
levels(f.var)  # get allowed values
table(f.var)  # get contingency (frequency) table
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Date and Time Objects}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Factors are vectors whose elements can have only certain values,
      \vskip1ex
      Factors are designed to describe categorical data which can only take certain values,
      \vskip1ex
      The function \texttt{factor()} converts a character vector into a factor,
      \vskip1ex
      Factors have two attributes: \texttt{class} ("\texttt{factor}") and \texttt{levels} (the allowed values),
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE,prompt=TRUE>>=
f.var <- factor(c('b', 'c',  # create factor vector
                'd', 'a', 'c', 'b'))
class(f.var)  # get object class
levels(f.var)  # get allowed values
table(f.var)  # get contingency (frequency) table
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Data Frames}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Data frames are 2-D objects (like matrices), but the columns can be of different classes,
      \vskip1ex
      Data frames can also be thought of as lists in which all the elements are vectors of the same length,\\
      Each list element is a column of elements of the same class,
      \vskip1ex
      Data frames share properties of both lists and matrices,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE,prompt=TRUE>>=
v.type <- c('rose', 'daisy', 'tulip')  # character vector
v.color <- c('red', 'white', 'yellow')  # character vector
v.price <- c(1.5, 0.5, 1.0)  # numeric vector
df.florist <- data.frame(v.type,  # create a data frame
                         v.color, v.price)
rownames(df.florist) <- c('flower1',  # assign rownames
                          'flower2', 'flower3')
df.florist
dim(df.florist)  # get dimension attribute
colnames(df.florist)  # get the colnames attribute
rownames(df.florist)  # get the rownames attribute
class(df.florist)  # get object class
class(df.florist$v.type)  # get column class
class(df.florist$v.price)  # get column class
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Subsetting \subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Data frames can be subset in a similar way to lists and matrices,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=6:30,tidy=FALSE,prompt=TRUE>>=
v.type <- c('rose', 'daisy', 'tulip')  # character vector
v.color <- c('red', 'white', 'yellow')  # character vector
v.price <- c(1.5, 0.5, 1.0)  # numeric vector
df.florist <- data.frame(v.type,  # create a data frame
                         v.color, v.price)
rownames(df.florist) <- c('flower1',  # assign rownames
                          'flower2', 'flower3')
df.florist
df.florist[2, ]  # get second row
df.florist[2, 3]  # get second row and third column
df.florist[[3]]  # get third column
df.florist$v.color[3]  # get third row from column 'v.color'
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Exploring \subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{str()} compactly displays the structure of an $R$ object,
      \vskip1ex
      The functions \texttt{head()} and \texttt{tail()} display the first and last rows of an $R$ object,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=6:30,tidy=FALSE,prompt=TRUE>>=
v.type <- c('rose', 'daisy', 'tulip')  # character vector
v.color <- c('red', 'white', 'yellow')  # character vector
v.price <- c(1.5, 0.5, 1.0)  # numeric vector
df.florist <- data.frame(v.type,  # create a data frame
                         v.color, v.price)
rownames(df.florist) <- c('flower1',  # assign rownames
                          'flower2', 'flower3')
df.florist
str(df.florist)  # display the object structure
dim(cars)  # the cars data frame has 50 rows
head(cars, n=5)  # get first five rows
tail(cars, n=5)  # get last five rows
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Sorting \subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Data frames can be sorted on any column,
      \vskip1ex
      The function \texttt{order()} returns a permutation vector,
      \vskip1ex
      \texttt{order()} can take several vectors as input, to break any ties,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=6:30,tidy=FALSE,prompt=TRUE>>=
v.type <- c('rose', 'daisy', 'tulip')  # character vector
v.color <- c('red', 'white', 'yellow')  # character vector
v.price <- c(1.5, 0.5, 1.0)  # numeric vector
df.florist <- data.frame(v.type,  # create a data frame
                         v.color, v.price)
rownames(df.florist) <- c('flower1',  # assign rownames
                          'flower2', 'flower3')
df.florist
order(df.florist$v.price)  # permute on price
df.florist[order(df.florist$v.price), ]  # sort on price
df.florist[order(df.florist$v.color), ]  # sort on color
order(c(2, 1:4))  # there's a tie
order(c(2, 1:4), 1:5)  # there's a tie
# read sort() Examples
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Reading and Writing \subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.35\textwidth}
      The functions \texttt{read.table()} and \texttt{write.table()} read and write data frames from files,
      \vskip1ex
      The functions \texttt{read.csv()} and \texttt{write.csv()} are wrappers for \texttt{read.table()} and \texttt{write.table()}, and read and write data frames from CSV format files,
      \vskip1ex
      \texttt{read.table()} and \texttt{write.table()} are inefficient for very large data sets,
    \column{0.65\textwidth}
      \vspace{-1em}
      <<echo=6:30,tidy=FALSE,prompt=TRUE>>=
v.type <- c('rose', 'daisy', 'tulip')  # character vector
v.color <- c('red', 'white', 'yellow')  # character vector
v.price <- c(1.5, 0.5, 1.0)  # numeric vector
df.florist <- data.frame(v.type,  # create a data frame
                         v.color, v.price)
rownames(df.florist) <- c('flower1',  # assign rownames
                          'flower2', 'flower3')
write.csv(df.florist, file='florist.csv')  # write to file
df.bad <- read.csv(file='badflorist.csv')  # read from file
df.bad  # v.price has bad data point
class(df.bad$v.price)  # numeric coerced to factor by bad data
df.bad$v.price <- as.numeric(  # explicitly coerce to numeric
                            as.character(df.bad$v.price))
df.bad$v.price[2] <- 0.5  # fix value
mean(df.bad$v.price)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Bad Data}
\begin{frame}[fragile,t]{Types of \subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Possible sources of bad data are: imported data, class coercion, numeric overflow,
      \vskip1ex
      Types of bad data:
      \begin{itemize}[]
        \item \texttt{NA} means Not Available (missing) data,
        \item \texttt{NaN} means Not a Number data,
        \item \texttt{Inf} means numeric overflow - divide by zero,
      \end{itemize}
      \vskip1ex
      The functions \texttt{is.na()} and \texttt{is.nan()} test for NA and NaN values,
      \vskip1ex
      Many functions have a \texttt{na.rm} parameter to remove NAs from input data,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<tidy=FALSE,prompt=TRUE>>=
as.numeric(c(1:3, "a"))  # NA from coercion
0/0  # NaN from ambiguous math
1/0  # Inf from divide by zero
is.na(c(NA, 0/0, 1/0))  # test for NA
is.nan(c(NA, 0/0, 1/0))  # test for NaN
NA*1:4  # create vector of Nas
v.na <- c(1, 2, NA, 4, NA, 5)  # create vector with some NA values
mean(v.na)  # returns NA, when NAs are input
mean(v.na, na.rm=TRUE)  # remove NAs from input data
v.na[!is.na(v.na)]  # delete the NA values
sum(!is.na(v.na))  # count non-NA values
      @
  \end{columns}
\end{block}

\begin{block}{}
  \texttt{NULL} isn't bad data, but is a reserved word and represents a null object,\\
  \texttt{NULL} is returned by functions whose value is undefined,\\
  Very often variables are initialized to \texttt{NULL} before iteration,\\
\end{block}

\end{frame}


\begin{frame}[fragile,t]{Scrubbing \subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{complete.cases()} returns \texttt{TRUE} if a row has no \texttt{NA} values,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE,prompt=TRUE>>=
head(airquality)  # airquality data has some NAs
dim(airquality)
sum(!complete.cases(airquality))  # number of NAs
head(airquality[!complete.cases(airquality), ])  # display some NAs
      @
  \end{columns}
\end{block}

\end{frame}


\begin{frame}[fragile,t]{Scrubbing \subsecname \hskip0.5em (cont.)}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Rows containing bad data may be either removed or replaced with an estimated value,
      \vskip1ex
      The library \texttt{zoo} is designed for managing time series and ordered objects,
      \vskip1ex
      The function \texttt{na.locf()} replaces NAs with most recent non-NA prior to it,
      \vskip1ex
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE,prompt=TRUE>>=
good.air <- airquality[complete.cases(airquality), ]  # remove NAs
dim(good.air)
head(good.air)  # NAs removed
library(zoo)  # load package zoo
good.air <- na.locf(airquality)  # replace NAs
dim(good.air)
head(good.air)  # NAs replaced
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading and Writing Matrices}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.35\textwidth}
      The functions \texttt{read.csv()} and \texttt{write.csv()} allow reading and writing matrices from CSV format files,
      \vskip1ex
      Using the \texttt{*.csv()} functions is very inefficient for large data sets,
    \column{0.65\textwidth}
      \vspace{-1em}
      <<echo=2:30,tidy=FALSE,prompt=TRUE>>=
m.var <- matrix(1:6, nrow=2, ncol=3, dimnames=list(c("row1", "row2"), c("col1", "col2", "col3")))  # create a matrix
m.var
write.csv(m.var, file='matrix.csv')  # write to file
m.in <- read.csv(file='matrix.csv')  # read from file
m.in  # this is a data frame!
class(m.in)  # this is a data frame!
name.rows <- as.character(m.in[, 1])  # get rownames
m.in <- as.matrix(m.in[, -1])  # coerce to matrix
rownames(m.in) <- name.rows  # restore rownames
m.in
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em (cont.)}
\begin{block}{}
  \begin{columns}[T]
    \column{0.35\textwidth}
      There are many other ways of reading and writing matrices from files, with tradeoffs between simplicity, data size, and speed,
      \vskip1ex
      Reading and writing matrices without rownames can be simplified,
      \vskip1ex
      The function \texttt{write.matrix()} is part of library \texttt{MASS},
      \vskip1ex
      The advantage of using the \texttt{scan()} function is its speed, but it doesn't handle rownames,\\
      Although aa test with 300x100 matrix showed almost same system.time(),
    \column{0.65\textwidth}
      \vspace{-1em}
      <<echo=2:30,tidy=FALSE,prompt=TRUE>>=
m.var <- matrix(1:6, nrow=2, ncol=3,  # create a matrix without rownames
                dimnames=list(NULL, c("col1", "col2", "col3")))
m.var  # matrix without rownames
library('MASS')  # load library 'MASS'
write.matrix(m.var, file='matrix.csv',  # write to CSV file by row - it's very SLOW!!!
                               sep=',')
system.time(m.in <- scan(file='matrix.csv',  # skip first line with colnames
                                  sep=',', skip=1, what=numeric()))
m.in  # this is a vector!
m.in <- matrix(m.in, nrow=2, byrow=TRUE)  # coerce by row to matrix
#        dim(m.in) <- c(2, 3)  # coerce by column to matrix!
name.cols <- readLines(con='matrix.csv', n=1)  # read colnames
name.cols  # this is a string!
name.cols <- strsplit(name.cols, s=',')[[1]]  # convert to char vector
colnames(m.in) <- name.cols  # restore colnames
m.in
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Functions}


%%%%%%%%%%%%%%%
\subsection{Calling Functions}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{save()} combine values into a vector or a list,\\
      Reading the help file,\\
      default argument values,\\
      elipsis argument,\\
    \column{0.6\textwidth}
      \vspace{-1em}
      <<eval=FALSE,prompt=TRUE>>=
save(n.var1, n.var2,  # save selected objects
     file="C:/jerzy/temp/my_data.RData")

save(..., list=character(),
     file=stop("'file' must be specified"),
     ascii=FALSE, version=NULL, envir=parent.frame(),
     compress=!ascii, compression_level,
     eval.promises=TRUE, precheck=TRUE)
      @
  \end{columns}
\end{block}
\pause

\begin{block}{\color{red}{Rule of Thumb}}
Use "\texttt{<-}" in $R$ scripts,\\
Use "\texttt{=}" in function calls.\\
\end{block}

\end{frame}


\end{document}
