% Define knitr options
% !Rnw weave = knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE, comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=6, fig.height=5)
options(width=60, dev='pdf')
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% amsmath package for math symbols
% \usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE6811_bib.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text footnotesize
\renewcommand\UrlFont{\footnotesize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape,bg=red,fg=red}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[FRE6811 Lecture\#1]{FRE6811 Financial Software Laboratory}
\subtitle{Lecture\#1, Spring 2014}
% \subject{Getting Started With R}
\institute[NYU Polytechnic]{NYU Polytechnic School of Engineering}
\titlegraphic{\includegraphics[scale=0.8]{engineering_long_color}}
\author{Jerzy Pawlowski}
% \email{jp3900@poly.edu}
\date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle


%%%%%%%%%%%%%%%
\section{Basic Operations in $R$}


%%%%%%%%%%%%%%%
\subsection{Assignment Operators}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The standard assignment operator in $R$ is "\texttt{<-}",
      \vskip1ex
      Both "\texttt{<-}" and "\texttt{=}" are valid assignment operators in $R$,
      \vskip1ex
      But they differ in \emph{scope} and  \emph{precedence} ("\texttt{<-}" has higher precedence than "\texttt{=}"),
      \vskip1ex
      The "\texttt{=}" operator is used for named arguments in function calls,
    \column{0.5\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
n.var1 <- 3 - 1
n.var1
n.var1 = 3 - 1
n.var1
      @
  \end{columns}
\end{block}
\pause

\begin{block}{\color{red}{Rule of Thumb}}
  Use "\texttt{<-}" in $R$ scripts,
  \vskip1ex
  Use "\texttt{=}" in function calls.
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The $R$ Workspace}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The workspace is the current $R$ working environment, which includes all user-defined objects and the command history,
      \vskip1ex
      The function \texttt{ls()} returns names of objects in the $R$ workspace,
      \vskip1ex
      The function \texttt{rm()} removes objects from the $R$ workspace,
      \vskip1ex
      The workspace can be saved into and loaded back from an $*.RData$ file (binary file format),
      \vskip1ex
      The function \texttt{save.image()} saves the whole workspace,
      \vskip1ex
      The function \texttt{save()} saves just the selected objects,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
n.var1 <- 3  # define new object
ls()  # list objects
save.image()  # save workspace to file .RData in cwd
rm(n.var1)  # remove object
ls()  # list objects
load(".RData")
ls()  # list objects
n.var2 <- 5  # define another object
save(n.var1, n.var2,  # save selected objects
     file="C:/jerzy/temp/my_data.RData")
rm(n.var1, n.var2)  # remove objects
ls()  # list objects
load(file="C:/jerzy/temp/my_data.RData")
ls()  # list objects
      @
  \end{columns}
\end{block}
% \pause

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em (cont.)}

\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      When you quit $R$ you'll be prompted "Save workspace image?"
      \vskip1ex
      If you answer $YES$ then the workspace will be saved into the $.RData$ file in the $cwd$,
      \vskip1ex
      When you start $R$ again, the workspace will be automatically loaded from the existing $.RData$ file,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<eval=FALSE,prompt=TRUE>>=
        q()  # quit R session
      @
  \end{columns}
\end{block}
\pause

\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{history()} displays recent commands,
      \vskip1ex
      You can also save and load the command history from a file,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<eval=FALSE,prompt=TRUE>>=
history(5)  # display last 5 commands
savehistory(file="myfile")  # default is ".Rhistory" 
loadhistory(file="myfile")  # default is ".Rhistory"
      @
  \end{columns}
\end{block}
% \pause

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Bad Data}
\begin{frame}[fragile,t]{Types of \subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Possible sources of bad data are: imported data, class coercion, numeric overflow,
      \vskip1ex
      Types of bad data:
      \begin{itemize}[]
        \item \texttt{NA} means Not Available (missing) data,
        \item \texttt{NaN} means Not a Number data,
        \item \texttt{Inf} means numeric overflow - divide by zero,
      \end{itemize}
      \vskip1ex
      The functions \texttt{is.na()} and \texttt{is.nan()} test for NA and NaN values,
      \vskip1ex
      Many functions have a \texttt{na.rm} parameter to remove NAs from input data,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
as.numeric(c(1:3, "a"))  # NA from coercion
0/0  # NaN from ambiguous math
1/0  # Inf from divide by zero
is.na(c(NA, 0/0, 1/0))  # test for NA
is.nan(c(NA, 0/0, 1/0))  # test for NaN
NA*1:4  # create vector of Nas
v.na <- c(1, 2, NA, 4, NA, 5)  # create vector with some NA values
mean(v.na)  # returns NA, when NAs are input
mean(v.na, na.rm=TRUE)  # remove NAs from input data
v.na[!is.na(v.na)]  # delete the NA values
sum(!is.na(v.na))  # count non-NA values
      @
  \end{columns}
\end{block}

\begin{block}{}
  \texttt{NULL} isn't bad data, but is a reserved word and represents a null object,\\
  \texttt{NULL} is returned by functions whose value is undefined,\\
  Very often variables are initialized to \texttt{NULL} before iteration,\\
\end{block}

\end{frame}


\begin{frame}[fragile,t]{Scrubbing \subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{complete.cases()} returns \texttt{TRUE} if a row has no \texttt{NA} values,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
head(airquality)  # airquality data has some NAs
dim(airquality)
sum(!complete.cases(airquality))  # number of NAs
head(airquality[!complete.cases(airquality), ])  # display some NAs
      @
  \end{columns}
\end{block}

\end{frame}


\begin{frame}[fragile,t]{Scrubbing \subsecname \hskip0.5em (cont.)}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Rows containing bad data may be either removed or replaced with an estimated value,
      \vskip1ex
      The function \texttt{na.locf()} from library \texttt{zoo} replaces NAs with most recent non-NA prior to it,
      \vskip1ex
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
good.air <- airquality[complete.cases(airquality), ]  # remove NAs
dim(good.air)
head(good.air)  # NAs removed
library(zoo)  # load package zoo
good.air <- na.locf(airquality)  # replace NAs
dim(good.air)
head(good.air)  # NAs replaced
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Reading and Writing Matrices}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.35\textwidth}
      The functions \texttt{read.csv()} and \texttt{write.csv()} allow reading and writing matrices from CSV format files,
      \vskip1ex
      Using the \texttt{*.csv()} functions is very inefficient for large data sets,
    \column{0.65\textwidth}
      \vspace{-1em}
      <<echo=2:30,tidy=FALSE,prompt=TRUE>>=
m.var <- matrix(1:6, nrow=2, ncol=3, dimnames=list(c("row1", "row2"), c("col1", "col2", "col3")))  # create a matrix
m.var
write.csv(m.var, file='matrix.csv')  # write to file
m.in <- read.csv(file='matrix.csv')  # read from file
m.in  # this is a data frame!
class(m.in)  # this is a data frame!
name.rows <- as.character(m.in[, 1])  # get rownames
m.in <- as.matrix(m.in[, -1])  # coerce to matrix
rownames(m.in) <- name.rows  # restore rownames
m.in
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em (cont.)}
\begin{block}{}
  \begin{columns}[T]
    \column{0.35\textwidth}
      There are many other ways of reading and writing matrices from files, with tradeoffs between simplicity, data size, and speed,
      \vskip1ex
      Reading and writing matrices without rownames can be simplified,
      \vskip1ex
      The function \texttt{write.matrix()} is part of library \texttt{MASS},
      \vskip1ex
      The advantage of using the \texttt{scan()} function is its speed, but it doesn't handle rownames,\\
      Although aa test with 300x100 matrix showed almost same system.time(),
    \column{0.65\textwidth}
      \vspace{-1em}
      <<echo=2:30,tidy=FALSE,prompt=TRUE>>=
m.var <- matrix(1:6, nrow=2, ncol=3,  # create a matrix without rownames
                dimnames=list(NULL, c("col1", "col2", "col3")))
m.var  # matrix without rownames
library('MASS')  # load library 'MASS'
write.matrix(m.var, file='matrix.csv',  # write to CSV file by row - it's very SLOW!!!
                               sep=',')
system.time(m.in <- scan(file='matrix.csv',  # skip first line with colnames
                                  sep=',', skip=1, what=numeric()))
m.in  # this is a vector!
m.in <- matrix(m.in, nrow=2, byrow=TRUE)  # coerce by row to matrix
#        dim(m.in) <- c(2, 3)  # coerce by column to matrix!
name.cols <- readLines(con='matrix.csv', n=1)  # read colnames
name.cols  # this is a string!
name.cols <- strsplit(name.cols, s=',')[[1]]  # convert to char vector
colnames(m.in) <- name.cols  # restore colnames
m.in
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Data Structures}


%%%%%%%%%%%%%%%
\subsection{\secname\hskip0.5em in $R$}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      Homogeneous data structures contain objects of the same class,
      \vskip1ex
      Heterogeneous structures can contain objects of different classes,
    \column{0.5\textwidth}
%      \vspace{-1em}
      \renewcommand\arraystretch{1.5} % scale table rows
      \renewcommand\tabcolsep{8pt} % set table column width - 6pt is default
      \centering{{\color{blue}{$R$ Data Structures}}}\\[1ex]
      \begin{tabular}{c||c|c|}
        & \text{Homogeneous} & \text{Heterogeneous} \\
        \hline
        \hline
        \text{1-dim} & Vectors & Lists \\
        \hline
        \text{2-dim} & Matrices & Data frames \\
        \hline
        \text{n-dim} & Arrays & NA \\
      \end{tabular}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Character Strings}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Strings are character objects of length one,
      \vskip1ex
      The function \texttt{paste()} converts elements to characters and concatenates them into a string,
      \vskip1ex
      The function \texttt{cat()} concatenates and writes to output,\\
      The function \texttt{cat()} is useful in user-defined functions,\\
      The recycling rule extends the length to match the longest object,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
s.var1 <- "Hello"  # define a character string
s.var2 <- "World!"  # define a character string
paste(s.var1, s.var2, sep=' ')  # concatenate
paste('a', 1:4, sep='-')  # convert, recycle and concatenate
cat(s.var1, s.var2)  # concatenate and write to output
strsplit("Hello World", split='r')  # split string
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Vectors}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{c()} combines values into a vector or a list,
      \vskip1ex
      Vectors can be indexed (subset) using vectors of:
      \begin{itemize}[]
        \item positive integers,
        \item negative integers,
        \item characters,
        \item logical vectors,
      \end{itemize}
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
v.var <- c(pi, exp(1), -digamma(1))  # define a vector
v.var
v.var[2]  # get second element
v.var[-2]  # get all elements, except the second element
v.var[c(F, T, T)]  # get second and third elements
v.var == v.var[2]  # logical vector of elements equal to the second one
v.var < 1  # logical vector of elements less than one
v.var[v.var > 1]  # get all elements greater than one
      @
  \end{columns}
\end{block}
\pause

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vectors can be multiplied and squared element by element,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
v.var <- c(pi, exp(1), -digamma(1))
v.var
2*v.var  # multiply all elements by 2
v.var^2  # square all elements
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em (cont.)}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vector elements can be assigned $names$,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
v.var <- c(pi=pi, euler=exp(1), gamma=-digamma(1))
v.var
names(v.var)  # get names of elements
v.var['euler']  # get element named 'euler'
names(v.var) <- c("pie","eulery","gammy")  # rename elements
v.var
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em of Numbers}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{seq()} returns a vector of numbers,
      \vskip1ex
      Another way of producing a vector of numbers is by using the "\texttt{:}" operator,
      \vskip1ex
      \texttt{letters} is a constant and a vector,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
seq(from=0, to=1, len=11)  # vector of decimals from 0 to 1.0
seq(from=0, to=1, by=0.1)  # vector of decimals from 0 to 1.0
0:10  # vector of integers from 0 to 10
(0:10)/10  # vector of decimals from 0 to 1.0
letters[5:10]  # vector of letters
      @
  \end{columns}
\end{block}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Appending vectors,
      \vskip1ex
      The function \texttt{vector()} returns an empty vector,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
c(11, 5:10)  # append to vector
c(20:25, 5:10)  # append to vector
v.var <- vector()  # create empty vector
v.var <- vector("numeric",  # create numeric vector of zeros
                length=10)
c(v.var, 2.0)  # append to vector
c('a', letters[5:10])  # vector of letters
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Lists}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Lists are a type of vector that contain elements of different classes,
      \vskip1ex
      Lists are recursive object types,
      \vskip1ex
      Lists can be indexed (subset) using:
      \begin{itemize}[]
        \item the '\texttt{[[}' operator,
        \item the '\texttt{\$}' operator (for named lists only),
      \end{itemize}
      \vskip1ex
      Partial name matching allows subsetting with partial name, as long as it can be resolved, 
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
l.var <- list(c('a', 'b'), 1:4)  # create a list
l.var
typeof(l.var)
l.var[[2]]  # get second element
l.var[[2]][3]  # get third element of second element
l.var[[c(2, 3)]]  # get third element of second element
l.var <- list(first=c('a', 'b'),  # create named list
              second=1:4)
names(l.var)
l.var$second  # get second element
l.var$s  # get second element - partial name matching
l.var$second[3]  # get third element of second element
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Data Frames}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Data frames are 2-D objects (like matrices), but the columns can be of different classes,
      \vskip1ex
      Data frames can also be thought of as lists in which all the elements are vectors of the same length,\\
      Each list element is a column of elements of the same class,
      \vskip1ex
      Data frames share properties of both lists and matrices,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
v.type <- c('rose', 'daisy', 'tulip')  # character vector
v.color <- c('red', 'white', 'yellow')  # character vector
v.price <- c(1.5, 0.5, 1.0)  # numeric vector
df.florist <- data.frame(v.type,  # create a data frame
                         v.color, v.price)
rownames(df.florist) <- c('flower1',  # assign rownames
                          'flower2', 'flower3')
df.florist
dim(df.florist)  # get dimension attribute
colnames(df.florist)  # get the colnames attribute
rownames(df.florist)  # get the rownames attribute
class(df.florist)  # get object class
class(df.florist$v.type)  # get column class
class(df.florist$v.price)  # get column class
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Subsetting \subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Data frames can be subset in a similar way to lists and matrices,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=6:30,tidy=FALSE,prompt=TRUE>>=
v.type <- c('rose', 'daisy', 'tulip')  # character vector
v.color <- c('red', 'white', 'yellow')  # character vector
v.price <- c(1.5, 0.5, 1.0)  # numeric vector
df.florist <- data.frame(v.type,  # create a data frame
                         v.color, v.price)
rownames(df.florist) <- c('flower1',  # assign rownames
                          'flower2', 'flower3')
df.florist
df.florist[2, ]  # get second row
df.florist[2, 3]  # get second row and third column
df.florist[[3]]  # get third column
df.florist$v.color[3]  # get third row from column 'v.color'
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Exploring \subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The function \texttt{str()} compactly displays the structure of an $R$ object,
      \vskip1ex
      The functions \texttt{head()} and \texttt{tail()} display the first and last rows of an $R$ object,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=6:30,tidy=FALSE,prompt=TRUE>>=
v.type <- c('rose', 'daisy', 'tulip')  # character vector
v.color <- c('red', 'white', 'yellow')  # character vector
v.price <- c(1.5, 0.5, 1.0)  # numeric vector
df.florist <- data.frame(v.type,  # create a data frame
                         v.color, v.price)
rownames(df.florist) <- c('flower1',  # assign rownames
                          'flower2', 'flower3')
df.florist
str(df.florist)  # display the object structure
dim(cars)  # the cars data frame has 50 rows
head(cars, n=5)  # get first five rows
tail(cars, n=5)  # get last five rows
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Sorting \subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Data frames can be sorted on any column,
      \vskip1ex
      The function \texttt{order()} returns a permutation vector,
      \vskip1ex
      \texttt{order()} can take several vectors as input, to break any ties,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=6:30,tidy=FALSE,prompt=TRUE>>=
v.type <- c('rose', 'daisy', 'tulip')  # character vector
v.color <- c('red', 'white', 'yellow')  # character vector
v.price <- c(1.5, 0.5, 1.0)  # numeric vector
df.florist <- data.frame(v.type,  # create a data frame
                         v.color, v.price)
rownames(df.florist) <- c('flower1',  # assign rownames
                          'flower2', 'flower3')
df.florist
order(df.florist$v.price)  # permute on price
df.florist[order(df.florist$v.price), ]  # sort on price
df.florist[order(df.florist$v.color), ]  # sort on color
order(c(2, 1:4))  # there's a tie
order(c(2, 1:4), 1:5)  # there's a tie
# read sort() Examples
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Reading and Writing \subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.35\textwidth}
      The functions \texttt{read.table()} and \texttt{write.table()} read and write data frames from files,
      \vskip1ex
      The functions \texttt{read.csv()} and \texttt{write.csv()} are wrappers for \texttt{read.table()} and \texttt{write.table()}, and read and write data frames from CSV format files,
      \vskip1ex
      \texttt{read.table()} and \texttt{write.table()} are inefficient for very large data sets,
    \column{0.65\textwidth}
      \vspace{-1em}
      <<echo=6:30,tidy=FALSE,prompt=TRUE>>=
v.type <- c('rose', 'daisy', 'tulip')  # character vector
v.color <- c('red', 'white', 'yellow')  # character vector
v.price <- c(1.5, 0.5, 1.0)  # numeric vector
df.florist <- data.frame(v.type,  # create a data frame
                         v.color, v.price)
rownames(df.florist) <- c('flower1',  # assign rownames
                          'flower2', 'flower3')
write.csv(df.florist, file='florist.csv')  # write to file
df.bad <- read.csv(file='badflorist.csv')  # read from file
df.bad  # v.price has bad data point
class(df.bad$v.price)  # numeric coerced to factor by bad data
df.bad$v.price <- as.numeric(  # explicitly coerce to numeric
                            as.character(df.bad$v.price))
df.bad$v.price[2] <- 0.5  # fix value
mean(df.bad$v.price)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Data Types and Classes}


%%%%%%%%%%%%%%%
\subsection{$R$ Object Attributes}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      $R$ objects can have the following attributes:
      \begin{itemize}[]
        \item length,
        \item names,
        \item dimnames,
        \item dimensions,
        \item class,
        \item Other user-defined attributes/metadata,
      \end{itemize}
      \vskip1ex
      The function \texttt{attributes()} returns the attributes of an object,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
attributes(5:10)  # a simple vector has no attributes
v.var <- c(pi=pi, euler=exp(1), gamma=-digamma(1))
attributes(v.var)  # a named vector has 'names' attribute
class(attributes(v.var))  # the attribute is a list object 
length(v.var)
is.vector(v.var)  # is the object a vector?
is.vector(names(v.var))  # names are character vectors
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Type and Class of Objects}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The \texttt{type} of an  $R$ object represents how it's stored in memory,\\
      Examples of $R$ \texttt{types} are \texttt{double}, \texttt{character}, \texttt{list}, etc.
      \vskip1ex
      The \texttt{class} of an  $R$ object is an attribute used for function dispatching in S3 classes,\\
      Examples of $R$ \texttt{classes} are \texttt{character}, \texttt{numeric}, \texttt{matrix}, \texttt{factor}, \texttt{data.frame}, etc.
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
v.var <- c(pi=pi, euler=exp(1), gamma=-digamma(1))
typeof(v.var)  # get object type
class(v.var)  # get object class
typeof(names(v.var))
class(names(v.var))
v.var <- c(1:5, 'a')  # append to vector
v.var  # type coercion
class(v.var)  # get object class
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Type Coercion}
\begin{frame}[fragile,t]{\subsecname}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      When different objects are mixed in a vector, implicit coercion occurs so that every element in the vector is of the same class,
      \vskip1ex
      The rule is that coercion is into larger types (numeric values are coerced into character strings),
      \vskip1ex
      Objects can be explicitly coerced from one class to another using the \texttt{as.*} functions,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
c(1:3, 'a')  # implicit coercion
as.numeric(c(1:3, 'a'))  # explicit coercion
as.logical(0:3)
as.character(0:3)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Arrays and Matrices}


%%%%%%%%%%%%%%%
\subsection{Arrays and Matrices}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Arrays are vectors with a dimension attribute,
      \vskip1ex
      Matrices are two-dimensional arrays,
      \vskip1ex
      The dimension attribute of a matrix is an integer vector of length 2 (nrow, ncol),
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
m.var <- matrix(1:6, nrow=2, ncol=3)  # create a matrix
m.var  # by default matrices are constructed column-wise
class(m.var)  # matrix class
dim(m.var)  # get dimension attribute
rownames(m.var) <- c("row1", "row2")  # set the rownames attribute
colnames(m.var) <- c("col1", "col2", "col3")  # set the colnames attribute
m.var
names(m.var)  # get the names attribute
dimnames(m.var)  # get dimnames attribute
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{\subsecname \hskip0.5em (cont.)}

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vectors can be converted into matrices by adding a dimension attribute,
      \vskip1ex
      The attribute \texttt{dimnames} can be assigned a named list to convert into a named matrix,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE,prompt=TRUE>>=
m.var <- 1:6  # create a vector
dim(m.var) <- c(2, 3)  # convert into matrix by adding dimension attribute
dimnames(m.var) <- list('rows'=c('row1', 'row2'),  # set dimnames attribute
                        'columns'=c('col1', 'col2', 'col3'))
m.var
      @
  \end{columns}
\end{block}
\pause

\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Indexing (subsetting) matrices,
    \column{0.7\textwidth}
      \vspace{-1em}
      <<echo=2:20,prompt=TRUE>>=
m.var <- matrix(1:6, nrow=2, ncol=3)  # create a matrix
m.var
m.var[2, ]  # get second row
m.var[c(1,2), ]  # get first and second rows
m.var[ ,3]  # get third column
m.var[ ,-2]  # remove second column
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Binding Vectors and Matrices Together}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Vectors can be bound into matrices using the functions \texttt{cbind()} and \texttt{rbind()},
      \vskip1ex
      The \alert{recycling rule} allows operations on vectors of different lengths:\\
      \begin{enumerate}
        \item Vectors are scanned from left to right,
        \item Shorter vectors are extended in length by recycling their values until they match the length of longer vectors,
      \end{enumerate}
    \column{0.7\textwidth}
      \vspace{-1em}
      <<prompt=TRUE>>=
v.var1 <- c(1, 2, 3)
v.var2 <- c(4, 5, 6)
cbind(v.var1, v.var2)  # bind into columns
rbind(v.var1, v.var2)  # bind into rows
v.var2 <- c(4, 5, 6, 7)  # extend second vector to four elements
cbind(v.var1, v.var2)  # recycling rule applied
1:6 + c(10, 20)  # another example of recycling rule
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Factors}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      Factors are vectors whose elements can have only certain values,
      \vskip1ex
      Factors are designed to describe categorical data which can only take certain values,
      \vskip1ex
      The function \texttt{factor()} converts a character vector into a factor,
      \vskip1ex
      Factors have two attributes: \texttt{class} ("\texttt{factor}") and \texttt{levels} (the allowed values),
    \column{0.7\textwidth}
      \vspace{-1em}
      <<tidy=FALSE,prompt=TRUE>>=
f.var <- factor(c('b', 'c',  # create factor vector
                        'd', 'a', 'c', 'b'))
class(f.var)  # get object class
levels(f.var)  # get allowed values
table(f.var)  # get contingency (frequency) table
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Date and Time Series Objects}


%%%%%%%%%%%%%%%
\subsection{Date Objects}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      $R$ has a \texttt{Date} class for date objects (but without time),
      \vskip1ex
      The function \texttt{as.Date()} converts a character string into a date object,
      \vskip1ex
      $R$ stores \texttt{Date} objects as the number of days since January 1, 1970,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
Sys.Date()  # get today's date
my.date <- as.Date("2013-06-15")  # "%Y-%m-%d" or "%Y/%m/%d"
my.date
class(my.date)
as.Date("06-15-2013", "%m-%d-%Y")  # specify format
my.date + 20  # add 20 days
unclass(my.date)  # get internal integer representation
some.date <- as.Date("11/22/2013", "%m/%d/%Y")
some.date
# difference between dates
difftime(some.date, my.date, units="weeks")
weekdays(my.date)  # get day of the week
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{POSIXct} Date and Time Objects}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      $R$ has a class \texttt{POSIXct} for date and time objects,
      \vskip1ex
      The function \texttt{as.POSIXct()} converts a character string into a \texttt{POSIXct} object,
      \vskip1ex
      \texttt{format.POSIXct()} converts \texttt{POSIXct} objects to character strings,
      \vskip1ex
      $R$ stores \texttt{POSIXct} objects as the number of seconds since the epoch (January 1, 1970 UTC),
      \vskip1ex
      \texttt{UTC} is an acronym for "Universal Time Coordinated", is synonymous with \texttt{GMT}, but doesn't change with Daylight Saving Time,
      \vskip1ex
      \texttt{POSIX} is an acronym for "Portable Operating System Interface",
    \column{0.7\textwidth}
      \vspace{-2em}
      <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
Sys.time()  # get today's date and time
Sys.timezone()  # get time-zone
Sys.setenv(tz="UTC")  # set time-zone to UTC
# convert character string "%Y-%m-%d %H:%M:%S" to POSIXct object
as.POSIXct("2013-06-15 18:30:10")
Sys.setenv(tz="America/New_York")  # set time-zone to EDT
my.date <- as.POSIXct("2013-06-15 18:30:10", tz="America/New_York")
my.date
class(my.date)
my.date + 20  # add 20 seconds
unclass(my.date)  # get internal integer representation
format(my.date, tz="UTC")  # convert to character in different TZ
as.POSIXct(format(my.date, tz="UTC"))  # convert back to POSIXct
as.POSIXct(format(Sys.time(), tz="UTC")) - # difference between
  as.POSIXct(format(Sys.time(), tz=""))  # local time and UTC
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Date and Time Classes}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The \texttt{Date} class from the \texttt{base} package is suitable for \emph{daily} time series,
      \vskip1ex
      The \texttt{POSIXct} class from the \texttt{base} package is suitable for \emph{intra-day} time series,
      \vskip1ex
      The \texttt{yearmon} and  \texttt{yearqtr} classes from the \texttt{zoo} package are suitable for \emph{quarterly} and \emph{monthly} time series,
    \column{0.7\textwidth}
      \vspace{-3em}
      <<echo=3:30,tidy=FALSE>>=
rm(list=ls())
library(zoo)  # load package zoo
my.date <- Sys.Date()  # create date series of class 'Date'
daily.index <- my.date + 0:365  # daily series over one year
head(daily.index, 4)  # print first few dates
format(head(daily.index, 4), "%m/%d/%Y")  # print first few dates
# create daily date and time series of class 'POSIXct'
daily.index <- seq(Sys.time(), by="days", length.out=365)
head(daily.index, 4)  # print first few dates
format(head(daily.index, 4), "%m/%d/%Y %H:%M:%S")  # print first few dates
# create series of monthly dates of class 'zoo'
monthly.index <- yearmon(2010+0:36/12)
head(monthly.index, 4)  # print first few dates
# create series of quarterly dates of class 'zoo'
qrtly.index <- yearqtr(2010+0:16/4)
head(qrtly.index, 4)  # print first few dates
# convert quarterly 'zoo' dates to POSIXct
Sys.setenv(tz="UTC")
as.POSIXct(head(qrtly.index, 4))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{zoo} Time Series Objects}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{zoo} is designed for managing \emph{time series} and ordered objects,
      <<zoo_ts,echo=7:30,tidy=FALSE,fig.show='hide'>>=
rm(list=ls())
set.seed(1121)  # initialize the random number generator
par(oma=c(1, 1, 1, 1))  # set outer margins
par(mgp=c(2, 0.5, 0))  # set axis title and labels
par(mar=c(5, 1, 1, 1))  # set plot margins
par(cex.lab=0.8,  # set font scales
    cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(zoo)  # load package zoo
# create daily dates
my.index <- as.Date("2010-06-15") + 1:1000
# create zoo time series
ts.random <- zoo(cumsum(rnorm(1000)), 
                 order.by=my.index)
class(ts.random)  # class 'zoo'
tail(ts.random, 4)  # get last few elements
write.zoo(ts.random, file="ts.random.txt")
rm(ts.random)  # remove zoo object
ts.random <- read.zoo("ts.random.txt")  # read it back
tail(ts.random, 4)  # get last few elements
# call plot.zoo
plot(ts.random, xlab="", ylab="")
title(main="Random Prices", line=-1)  # add title
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_ts}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Operations on \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{coredata()} extracts the data contained in \texttt{zoo} object, and returns a vector or matrix,
      \vskip1ex
      The function \texttt{index()} extracts the time index of a \texttt{zoo} object,
      \vskip1ex
      The functions \texttt{start()} and \texttt{end()} return the time index values of the first and last elements of a \texttt{zoo} object,
      \vskip1ex
      The functions \texttt{cumsum()}, \texttt{cummax()}, and \texttt{cummin()} return cumulative sums, minima and maxima of a \texttt{zoo} object,
    \column{0.6\textwidth}
      \vspace{-2em}
      <<echo=3:30,tidy=FALSE>>=
rm(list=ls())
library(zoo)  # load package zoo
# create zoo time series
daily.index <- Sys.Date() + 0:3
zoo.ts <- zoo(rnorm(length(daily.index)), 
               order.by=daily.index)
zoo.ts
index(zoo.ts)  # extract time index
coredata(zoo.ts)  # extract coredata
zoo.ts[start(zoo.ts)]  # first element
zoo.ts[end(zoo.ts)]  # last element
coredata(zoo.ts) <- rep(1, 4)  # replace coredata
cumsum(zoo.ts)  # cumulative sum
cummax(cumsum(zoo.ts))
cummin(cumsum(zoo.ts))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{The \texttt{lag()} and \texttt{diff()} Functions}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{lag()} returns a lagged version of a time series, shifting the time index back by a given number of observations,
      \vskip1ex
      The function \texttt{diff()} returns the difference between a time series and its lagged version, 
      \vskip1ex
      For \texttt{zoo} objects, both these functions omit any \texttt{NA} values they may have produced,
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=2:30,tidy=FALSE>>=
library(zoo)  # load package zoo
coredata(zoo.ts) <- 1:4  # replace coredata
zoo.ts
diff(zoo.ts)  # diff with one day lag
lag(zoo.ts, 2)  # two day lag
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Sequential Joining \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{zoo} time series can be joined sequentially using \texttt{rbind},
      <<zoo_join_seq,echo=7:30,tidy=FALSE,fig.show='hide'>>=
rm(list=ls())
set.seed(1121)  # initialize the random number generator
par(oma=c(1, 1, 1, 1))  # set outer margins
par(mgp=c(2, 0.5, 0))  # set axis title and labels
par(mar=c(5, 1, 1, 1))  # set plot margins
par(cex.lab=0.8,  # set font scales
    cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(zoo)  # load package zoo
# create daily date series of class 'Date'
daily.index1 <- Sys.Date() + 0:365
# create zoo time series
zoo.ts1 <- zoo(rnorm(length(daily.index1)), 
                 order.by=daily.index1)
# create another zoo time series
daily.index2 <- Sys.Date() + 365:730
zoo.ts2 <- zoo(rnorm(length(daily.index2)), 
                 order.by=daily.index2)
# rbind the two time series
zoo.ts3 <- rbind(zoo.ts1,  # ts1 supersedes ts2
                 zoo.ts2[index(zoo.ts2) > 
                           end(zoo.ts1)])
plot(cumsum(zoo.ts3), xlab="", ylab="")
# add vertical line at stitch point
abline(v=index(tail(zoo.ts1, 1)), col="red", lty="dashed")
title(main="Random Prices", line=-1)  # add title
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_join_seq}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Merging \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \texttt{zoo} time series can be combined concurrently by joining their columns using \texttt{merge()},
      \vskip1ex
      If \texttt{all=TRUE}, then \texttt{merge()} uses the union of their dates, otherwise it uses their intersection,
      \vskip1ex
      The \texttt{merge()} operation can produce \texttt{NA} values,
      \vskip1ex
      \texttt{merge()} is similar to \texttt{cbind()},
    \column{0.7\textwidth}
      \vspace{-2em}
      <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
# create daily date series of class 'Date'
daily.index1 <- Sys.Date() + -3:1
# create zoo time series
zoo.ts1 <- zoo(rnorm(length(daily.index1)), 
               order.by=daily.index1)
# create another zoo time series
daily.index2 <- Sys.Date() + -1:3
zoo.ts2 <- zoo(rnorm(length(daily.index2)), 
               order.by=daily.index2)
merge(zoo.ts1, zoo.ts2)  # union of dates
merge(zoo.ts1, zoo.ts2, all=FALSE)  # intersection of dates
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Managing \texttt{NA} Values}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Operations on time series can produce \texttt{NA} values,
      \vskip1ex
      There are two dedicated functions for managing \texttt{NA} values in time series: 
      \begin{itemize}[]
        \item \texttt{na.omit()} removes observations containing \texttt{NA} values,
        \item \texttt{na.locf()} carries the last non-\texttt{NA} observation forward,
      \end{itemize}
    \column{0.6\textwidth}
      \vspace{-1em}
      <<echo=3:30,tidy=FALSE>>=
rm(list=ls())
library(zoo)  # load package zoo
# create zoo time series
zoo.ts <- zoo(rnorm(4), order.by=(Sys.Date() + 0:3))
zoo.ts[3] <- NA
zoo.ts

na.locf(zoo.ts)  # replace NA's using locf

na.omit(zoo.ts)  # remove NA's using omit
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Aggregating \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{aggregate()} performs temporal aggregations of \texttt{zoo} objects,
      <<zoo_agg,echo=8:30,tidy=FALSE,fig.show='hide'>>=
rm(list=ls())
set.seed(1121)  # initialize the random number generator
par(oma=c(1, 1, 1, 1))  # set outer margins
par(mgp=c(2, 0.5, 0))  # set axis title and labels
par(mar=c(5, 1, 1, 1))  # set plot margins
par(cex.lab=0.8,  # set font scales
    cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(zoo)  # load package zoo
# create zoo time series
daily.index <- Sys.Date() + 0:365
zoo.ts <- zoo(rnorm(length(daily.index)), 
                 order.by=daily.index)
# create monthly dates
dates.agg <- as.Date(as.yearmon(index(zoo.ts)))
# perform monthly 'mean' aggregation
zoo.agg <- aggregate(zoo.ts, by=dates.agg, 
                     FUN=mean)
# merge with original zoo - union of dates
zoo.agg <- merge(zoo.ts, zoo.agg)
# replace NA's using locf
zoo.agg <- na.locf(zoo.agg)
# extract aggregated zoo
zoo.agg <- zoo.agg[index(zoo.ts), 2]
# plot original and aggregated zoo
plot(cumsum(zoo.ts), xlab="", ylab="")
lines(cumsum(zoo.agg), lwd=2, col="red")
# add legend
legend("topright", inset=0.15, title="Aggregated Prices", 
       leg=c("orig prices", "agg prices"), lwd=2, 
       col=c("black", "red"))
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_agg}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Interpolating \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{zoo} has two functions for replacing \texttt{NA} values using interpolation:
      \begin{itemize}[]
        \item \texttt{na.approx()} performs linear interpolation,
        \item \texttt{na.spline()} performs spline interpolation,
      \end{itemize}
      \vspace{-1em}
      <<zoo_interpol,echo=6:30,tidy=FALSE,fig.show='hide'>>=
set.seed(1121)  # initialize the random number generator
par(oma=c(1, 1, 1, 1))  # set outer margins
par(mgp=c(2, 0.5, 0))  # set axis title and labels
par(mar=c(5, 1, 1, 1))  # set plot margins
par(cex.lab=0.8,  # set font scales
    cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# perform monthly 'mean' aggregation
zoo.agg <- aggregate(zoo.ts, by=dates.agg, 
                     FUN=mean)
# merge with original zoo - union of dates
zoo.agg <- merge(zoo.ts, zoo.agg)
# replace NA's using linear interpolation
zoo.agg <- na.approx(zoo.agg)
# extract interpolated zoo
zoo.agg <- zoo.agg[index(zoo.ts), 2]
# plot original and interpolated zoo
plot(cumsum(zoo.ts), xlab="", ylab="")
lines(cumsum(zoo.agg), lwd=2, col="red")
# add legend
legend("topright", inset=0.15, title="Interpolated Prices", 
       leg=c("orig prices", "interpol prices"), lwd=2, 
       col=c("black", "red"))
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_interpol}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Rolling Functions on \texttt{zoo} Objects}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The package \texttt{zoo} has several functions for rolling calculations:
      \begin{itemize}[]
        \item \texttt{rollapply()} applying function to rolling margins,
        \item \texttt{rollmean()} calculate rolling means,
        \item \texttt{rollmedian()} calculate rolling median,
        \item \texttt{rollmax()} calculate rolling max,
      \end{itemize}
      \vspace{-1em}
      <<zoo_roll,echo=6:30,tidy=FALSE,fig.show='hide'>>=
set.seed(1121)  # initialize the random number generator
par(oma=c(1, 1, 1, 1))  # set outer margins
par(mgp=c(2, 0.5, 0))  # set axis title and labels
par(mar=c(5, 1, 1, 1))  # set plot margins
par(cex.lab=0.8,  # set font scales
    cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
# perform monthly 'mean' aggregation
zoo.mean <- rollapply(zoo.ts, width=11, FUN=mean)
# merge with original zoo - union of dates
zoo.mean <- merge(zoo.ts, zoo.mean)
# replace NA's using na.locf
zoo.mean <- na.locf(zoo.mean, fromLast=TRUE)
# extract mean zoo
zoo.mean <- zoo.mean[index(zoo.ts), 2]
# plot original and interpolated zoo
plot(cumsum(zoo.ts), xlab="", ylab="")
lines(cumsum(zoo.mean), lwd=2, col="red")
# add legend
legend("topright", inset=0.15, title="Mean Prices", 
       leg=c("orig prices", "mean prices"), lwd=2, 
       col=c("black", "red"))
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_roll}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{RQuantLib} Calendar Functions}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      The package \texttt{RQuantLib} contains a large library of functions for pricing fixed-income instruments and options, and for risk management calculations,
      \vskip1ex
      The package \texttt{RQuantLib} contains calendar functions for determining holidays and business days in many different jurisdictions,
    \column{0.7\textwidth}
      \vspace{-2em}
      <<echo=3:30,tidy=FALSE>>=
rm(list=ls())
library(zoo)  # load zoo
library(RQuantLib)  # load RQuantLib
# create daily date series of class 'Date'
daily.index <- Sys.Date() + -5:2
daily.index
# create logical vector of business days
bus.days <- isBusinessDay(  # RQuantLib calendar
  calendar="UnitedStates/GovernmentBond", daily.index)
# create daily series of business days
bus.index <- daily.index[bus.days]
bus.index
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Package \texttt{tseries} for Time Series Analysis}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \vspace{-2em}
      <<tseries_intro,echo=6:30,tidy=FALSE,fig.show='hide'>>=
set.seed(1121)  # initialize the random number generator
par(oma=c(1, 1, 1, 1))  # set outer margins
par(mgp=c(2, 0.5, 0))  # set axis title and labels
par(mar=c(5, 1, 1, 1))  # set plot margins
par(cex.lab=0.8,  # set font scales
    cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
library(tseries)  # load package tseries
suppressWarnings(  # load MSFT data
  zoo.msft <- get.hist.quote(instrument="MSFT", 
                           start="2013-04-01", 
                           end=Sys.time(), 
                           origin="1970-01-01")
  )  # end suppressWarnings
class(zoo.msft)
dim(zoo.msft)
tail(zoo.msft, 4)

sharpe(zoo.msft[, "Close"], r=0.01)  # calculate Sharpe ratio

plot(zoo.msft[, "Close"], xlab="", ylab="")
title(main="MSFT Close Prices", line=-1)  # add title
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/tseries_intro}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Downloading Time Series Data Using Package \texttt{tseries}}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \vspace{-2em}
      <<zoo_plot_2y,echo=6:30,tidy=FALSE,fig.show='hide'>>=
set.seed(1121)  # initialize the random number generator
par(oma=c(1, 1, 1, 1))  # set outer margins
par(mgp=c(2, 0.5, 0))  # set axis title and labels
par(mar=c(5, 1, 1, 1))  # set plot margins
par(cex.lab=0.8,  # set font scales
    cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
suppressWarnings(  # load EUR/USD data
  zoo.eurusd <- get.hist.quote(
    instrument="EUR/USD", provider="oanda",
    start="2013-04-01", end=Sys.time(),
    origin="1970-01-01")
  )  # end suppressWarnings
# bind and scrub data
zoo.msfteur <- merge(zoo.eurusd, 
                     zoo.msft[, "Close"])
colnames(zoo.msfteur) <- c("EURUSD", "MSFT")
zoo.msfteur <- 
  zoo.msfteur[complete.cases(zoo.msfteur),]
### plot with two "y" axes
par(las=1)  # set text printing to "horizontal"
# plot first ts
plot(zoo.msfteur[, 1], xlab=NA, ylab=NA)
# set range for second "y" axis
par(usr=c(par("usr")[1:2], range(zoo.msfteur[,2])))
lines(zoo.msfteur[, 2], col="red")  # second plot
axis(side=4, col="red")  # second "y" axis on right
# print axis labels
mtext(colnames(zoo.msfteur)[1], side=2, padj=-6, line=-4)
mtext(colnames(zoo.msfteur)[2], col="red", side=4, padj=-2, line=-3)
title(main="EUR and MSFT", line=-1)  # add title
# add legend without box
legend("bottomright", legend=colnames(zoo.msfteur), 
       lty=c(1, 1), lwd=c(2, 2), col=c("black", "red"), bty="n")


##########

# slightly different method using par(new=TRUE)
# par(las=1)  # set text printing to "horizontal"
# plot(zoo.msfteur[, 1], xlab=NA, ylab=NA)
# par(new=TRUE)  # allow new plot on same chart
# plot(zoo.msfteur[, 2], xlab=NA, ylab=NA, yaxt="n", col="red")
# axis(side=4, col="red")  # second "y" axis on right
# mtext(colnames(zoo.msfteur)[1], side=2, padj=-6, line=-4)
# mtext(colnames(zoo.msfteur)[2], col="red", side=4, padj=-2, line=-3)
# title(main="EUR and MSFT", line=-1)  # add title
# legend("bottomright", legend=colnames(zoo.msfteur), 
#        lty=c(1, 1), lwd=c(2, 2), col=c("black", "red"), bty="n")

##########

# "x" axis with monthly ticks - doesn't work
# plot first ts wthout "x" axis
# plot(zoo.msfteur[, 1], xaxt="n", xlab=NA, ylab=NA)
# # add "x" axis with monthly ticks
# month.ticks <- unique(as.yearmon(index(zoo.eurusd)))
# axis(side=1, at=month.ticks, labels=format(month.ticks, "%b-%y"), tcl=-0.7)

      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/zoo_plot_2y}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Time Series Classes in $R$}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      $R$ has a number of different time series classes:
      \begin{itemize}[]
        \item Class \texttt{ts} from base package \texttt{stats},
        \item Class \texttt{zoo} ordered observations,
        \item Class \texttt{xts} extension of \texttt{zoo} class,
        \item Class \texttt{timeSeries} from the \emph{Rmetrics} suite,
      \end{itemize}
    \column{0.6\textwidth}
      \vspace{-2em}
      <<echo=1:30,tidy=FALSE>>=
ts.msft <- as.ts(zoo.msft)
class(ts.msft)
# rename colnames
colnames(ts.msft) <- paste0("MSFT.", colnames(ts.msft))
tail(ts.msft, 4)

library(timeSeries)
tser.msft <- as.timeSeries(zoo.msft)
class(ts.msft)
tail(tser.msft, 4)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Plotting Using Package \texttt{ggplot2}}


%%%%%%%%%%%%%%%
\subsection{Plotting \texttt{zoo} Time Series Using \texttt{ggplot2}}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \vspace{-2em}
      <<quantlib_plot,echo=3:30,tidy=FALSE,fig.width=6,fig.height=7,fig.show='hide'>>=
rm(list=ls())
library(zoo)  # load zoo
library(ggplot2)  # load ggplot2
library(gridExtra)
# coerce to zoo
zoo.eustx <- as.zoo(EuStockMarkets)
# coerce index into class 'Dates'
index(zoo.eustx) <- 
  as.Date(365*(index(zoo.eustx)-1970))
# plot ggplot2 in single pane
ggp.zoo1 <- autoplot(zoo.eustx, main="Eu Stox", 
         facets=NULL) + xlab("") + 
  theme(legend.position=c(0.1, 0.5), 
  plot.title=element_text(vjust=-2.0), 
  plot.margin=unit(c(-0.5, 0.0, -0.5, 0.0), "cm"), 
  plot.background=element_blank(),
  axis.text.y=element_blank()
  )
# plot ggplot2 in multiple panes
ggp.zoo2 <- autoplot(zoo.eustx, main="Eu Stox", 
         facets=Series ~ .) + xlab("") + 
  theme(legend.position=c(0.1, 0.5), 
  plot.title=element_text(vjust=-2.0), 
  plot.margin=unit(c(-0.5, 0.0, -0.5, 0.0), "cm"), 
  plot.background=element_blank(),
  axis.text.y=element_blank()
  )
# create plot ggplot2 in multiple panes
grid.arrange(ggp.zoo1, ggp.zoo2, ncol=1)
      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \hspace*{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/quantlib_plot}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Functions}


%%%%%%%%%%%%%%%
\subsection{Calling Functions}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{save()} combine values into a vector or a list,\\
      Reading the help file,\\
      default argument values,\\
      elipsis argument,\\
    \column{0.6\textwidth}
      \vspace{-1em}
      <<eval=FALSE,prompt=TRUE>>=
save(n.var1, n.var2,  # save selected objects
     file="C:/jerzy/temp/my_data.RData")

save(..., list=character(),
     file=stop("'file' must be specified"),
     ascii=FALSE, version=NULL, envir=parent.frame(),
     compress=!ascii, compression_level,
     eval.promises=TRUE, precheck=TRUE)
      @
  \end{columns}
\end{block}
\pause

\begin{block}{\color{red}{Rule of Thumb}}
Use "\texttt{<-}" in $R$ scripts,\\
Use "\texttt{=}" in function calls.\\
\end{block}

\end{frame}


\end{document}
