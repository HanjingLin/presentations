% Define knitr options
% !Rnw weave = knitr
% Set global chunk options
<<knitr_setup,include=FALSE,cache=FALSE>>=
library(knitr)
opts_chunk$set(prompt=TRUE,comment=NA, highlight=FALSE, message=FALSE, warning=FALSE, size='scriptsize', fig.width=4, fig.height=4)
options(width=60, dev='pdf')
thm <- knit_theme$get("acid")
knit_theme$set(thm)
@


% Define document options
\documentclass[10pt]{beamer}
\mode<presentation>
\usetheme{AnnArbor}
% \usecolortheme{whale}
% Uncover everything in a step-wise fashion
% \beamerdefaultoverlayspecification{<+->}
% amsmath package for math symbols
% \usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex} % bibstyle=numeric
% \bibliographystyle{amsalpha} % doesn't work
\addbibresource{FRE6811_bib.bib}
% \addbibresource[location=remote]{http://www.citeulike.org/user/jerzyp}
\renewcommand\bibfont{\footnotesize}
\renewcommand{\pgfuseimage}[1]{\scalebox{0.75}{\includegraphics{#1}}} % scale bib icons
\setbeamertemplate{bibliography item}[text] % set bib icons
% \setbeamertemplate{bibliography item}{} % remove bib icons

% \usepackage{enumerate}
% \let\emph\textbf
% \let\alert\textbf
% Define colors for hyperlinks
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks=true,linkcolor=,urlcolor=links}
% Make url text footnotesize
\renewcommand\UrlFont{\footnotesize}
% Make institute text italic and small
\setbeamerfont{institute}{size=\small,shape=\itshape,bg=red,fg=red}
\setbeamerfont{date}{size=\small}
\setbeamerfont{block title}{size=\normalsize} % shape=\itshape
\setbeamerfont{block body}{size=\footnotesize}


% Title page setup
\title[Control Statements and Recursion]{Control Statements and Recursion}
\subtitle{FRE6811 Financial Software Laboratory, Spring 2014}
% \subject{Getting Started With R}
\institute[NYU Polytechnic]{NYU Polytechnic School of Engineering}
\titlegraphic{\includegraphics[scale=0.8]{engineering_long_color}}
\author{Jerzy Pawlowski}
% \email{jp3900@poly.edu}
\date{\today}
% \pgfdeclareimage[height=0.5cm]{university-logo}{engineering_long_white}
% \logo{\pgfuseimage{engineering_long_white}}


%%%%%%%%%%%%%%%
\begin{document}


%%%%%%%%%%%%%%%
\maketitle


%%%%%%%%%%%%%%%
\section{Operators}


%%%%%%%%%%%%%%%
\subsection{Logical Operators}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      $R$ has the following logical operators:
      \begin{itemize}
        \item '\texttt{<}' less than,
        \item '\texttt{<=}' less than or equal to,
        \item '\texttt{>}' greater than,
        \item '\texttt{>=}' greater than or equal to,
        \item '\texttt{==}' exactly equal to,
        \item '\texttt{!=}' not equal to,
        \item '\texttt{!x}' Not \texttt{x},
        \item '\texttt{x \& y}' \texttt{x} AND \texttt{y},
        \item '\texttt{x | y}' \texttt{x} OR \texttt{y},
      \end{itemize}
      These operators are applied to vectors element-wise,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
TRUE | FALSE
TRUE | NA
v.var1 <- c(2, 4, 6)
v.var1 < 5
(v.var1 < 5) & (v.var1 > 3)
v.var1[(v.var1 < 5) & (v.var1 > 3)]
v.var2 <- c(-10, 0, 10)
v.var1 < v.var2
c(FALSE, TRUE, FALSE) & c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, FALSE) | c(TRUE, TRUE, FALSE)
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Long Form Logical Operators}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      $R$ also has two long form logical operators:
      \begin{itemize}
        \item '\texttt{x \&\& y}' \texttt{x} AND \texttt{y},
        \item '\texttt{x || y}' \texttt{x} OR \texttt{y},
      \end{itemize}
      These operators differ from the short form operators in two ways:
      \begin{itemize}
        \item They only evaluate the first vector elements,
        \item They short-circuit (stop evaluation as soon as the expression is determined),
      \end{itemize}
      {\color{red}{Rule of Thumb}}
      \begin{itemize}
        \item Use '\texttt{\&\&}' and '\texttt{||}' in if-clauses,
      \end{itemize}
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
c(FALSE, TRUE, FALSE) && c(TRUE, TRUE, FALSE)
c(FALSE, TRUE, FALSE) || c(TRUE, TRUE, FALSE)
FuncTrue = function() {cat("FuncTrue\t"); TRUE}
FuncFalse = function() {cat("FuncFalse\t"); FALSE}
FuncTrue() | FuncFalse()
FuncTrue() || FuncFalse()  # FuncFalse() isn't evaluated at all!
v.var <- c(2, 4, 6)
# works (does nothing) using '&&'
if (is.matrix(v.var) && (v.var[2, 3] > 0)) {
  v.var[2, 3] <- 1
}
# no short-circuit so fails (throws an error)
if (is.matrix(v.var) & (v.var[2, 3] > 0)) {
  v.var[2, 3] <- 1
}
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Control Structures}


%%%%%%%%%%%%%%%
\subsection{'\texttt{if}' statements}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      $R$ has the familiar '\texttt{if() \{...\} else \{...\}}' statement to control execution flow depending on logical conditions,
      \vskip1ex
      The logical conditions must be either a logical or numeric type, otherwise an error is thrown,
      \vskip1ex
      The '\texttt{else}' statement can also be omitted,
      \vskip1ex
      '\texttt{if}' statements can be nested using multiple '\texttt{else if}' statements,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
n.var1 <- -1
if (n.var1) {  # positive numbers are TRUE, otherwise FALSE
  n.var2 <- 4
} else if (n.var1 == 0) {  # 'else if' together on same line
  n.var2 <- 0
} else {  # keep 'else' together with curly braces
  n.var2 <- -4
}
n.var2
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Function \texttt{ifelse()}}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      $R$ also has an \texttt{ifelse()} function that controls execution but it accepts and returns vectors,
        <<func_ifelse,echo=2:30,tidy=FALSE,fig.show='hide'>>=
rm(list=ls())
# create two vectors
v.var1 <- sin(0.25*pi*1:10)
v.var2 <- cos(0.25*pi*1:10)
# create third vector using 'ifelse'
v.var3 <- ifelse(v.var1 > v.var2, v.var1, 
                 v.var2)
# cbind all three together
v.var4 <- cbind(v.var1, v.var2, v.var3)

# set plotting parameters
par(mar=c(7, 2, 1, 2), mgp=c(2, 1, 0), 
    cex.lab=0.8, cex.axis=0.8, cex.main=0.8, 
    cex.sub=0.5)
# plot matrix
matplot(v.var4, type="l", lty="solid", 
        col=c("green", "blue", "red"), 
        lwd=c(2, 2, 2), xlab="", ylab="")
# add legend
legend(x="bottomright", legend=colnames(v.var4), 
       title="", inset=0.05, cex=0.8, lwd=2, 
       lty=c(1, 1, 1), col=c("green", "blue", "red"))
      @
    \column{0.5\textwidth}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/func_ifelse}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Iteration Using '\texttt{for}' and '\texttt{while}' Loops}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The '\texttt{for() \{...\}}' statement iterates over elements of a vector or list,
      \vskip1ex
      $R$ also has a '\texttt{while() \{...\}}' loop,
      \vskip1ex
      '\texttt{while}' loops start by testing their logical condition, and they repeat executing the loop body until that condition is \texttt{FALSE},
      \vskip1ex
      But '\texttt{while}' loops risk producing infinite loops if not written
properly, so \alert{Use Them With Care!}
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
my.colors <- list("red", "white", "blue")
for (some.color in my.colors) {  # loop over list
  print(some.color)
}
for (some.index in 1:3) {  # loop over vector
  print(my.colors[[some.index]])
}

some.index <- 1  # 'while' loops need initialization
while (some.index < 4) {  # while loop
  print(my.colors[[some.index]])
  some.index <- some.index + 1
}
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Fibonacci Sequence Using '\texttt{for}' Loop}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The \emph{Fibonacci} sequence of integers is defined by the recurrence relation:
      \begin{displaymath}
        F_{n} = F_{n-1} + F_{n-2},
      \end{displaymath}
      \begin{displaymath}
        F_{1} = 1, F_{2} = 1,
      \end{displaymath}
      \begin{displaymath}
        F_{n} = 0, 1, 1, 2, 3, 5, 8, 13, \ldots
      \end{displaymath}
      The \emph{Fibonacci} sequence was invented by \emph{Indian} mathematicians, and later described by \emph{Fibonacci} in his famous treatise \emph{Liber Abaci},
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
fib.seq <- c()  # create empty vector
fib.seq[1] <- 1  # initialize
fib.seq[2] <- 1  # initialize
for (i in 3:10) {  # perform recurrence loop
  fib.seq[i] <- fib.seq[i-1] + fib.seq[i-2]
}  # end for
fib.seq
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Simulation Using '\texttt{while}' Loops}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      '\texttt{while}' loops are often used in simulations, when the number of required loops is unknown in advance,
      \vskip1ex
      Below is an example of a simulation of random prices hitting a barrier level,
        <<rand_while,echo=7:30,fig.show='hide'>>=
# set plot paramaters - margins and font scale
par(oma=c(1, 1, 1, 1))  # set outer margins
par(mgp=c(2, 1, 0))  # set axis title and labels
par(mar=c(5, 1, 1, 1))  # set plot margins
par(cex.lab=0.8,  # set font scales
    cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
set.seed(1121)  # for reproducibility
max.simu <- 1000  # max simulation trials
v.simu <- 0*1:max.simu  # initialize trials
barrier.level <- 20  # barrier level
v.simu[1] <- rnorm(1)  # first simulation value
sim.index <- 2  # initialize simulation index
while ((sim.index <= max.simu) && 
         (v.simu[sim.index - 1] < barrier.level)) {
  v.simu[sim.index] <- v.simu[sim.index - 1] + rnorm(1)
  sim.index <- sim.index + 1
}  # end while
if (sim.index <= max.simu) {  # fill zero prices
  v.simu[sim.index:max.simu] <- v.simu[sim.index - 1]
}
# create daily time series starting 2011
ts.var <- ts(data=v.simu, frequency=365, start=c(2011, 1))
plot(ts.var, type="l", col="black",  # perform plot
     lty="solid", xlab="", ylab="")
abline(h=barrier.level, lwd=2, col="red")  # add horizontal line
title(main="Random Prices", line=0)  # add title
      @

    \column{0.5\textwidth}
      \vspace{-2em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/rand_while}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{apply()} Instead of '\texttt{for}' and '\texttt{while}' Loops}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      '\texttt{for}' and '\texttt{while}' loops are relatively inefficient and too slow for large computations,
      \vskip1ex
      '\texttt{apply()}' loops are much more efficient and preferred in practice,
      \vskip1ex
      The function '\texttt{system.time()}' returns the CPU time used to evaluate a given expression,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
large.matrix <- matrix(1:1000000, nrow=100000, ncol=10)
row.sums <- c()

system.time(
  for(i in 1:nrow(large.matrix)) {
    row.sums[i] <- sum(large.matrix[i,])
  }  # end for
)  # end system.time

system.time(row.sums <- apply(large.matrix, 1, sum))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Vectorized Functions for Matrix Computations}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      Even '\texttt{apply()}' loops are not the most efficient way to calculate statistics on rows and columns of very large matrices,
      \vskip1ex
      $R$ has very efficient functions for calculating sums and means of rows and columns:
      \begin{itemize}
        \item \texttt{rowSums()}
        \item \texttt{colSums()}
        \item \texttt{rowMeans()}
        \item \texttt{colMeans()}
      \end{itemize}
      These functions call compiled \texttt{C} code and are therefore much faster than even the \texttt{apply()} functions,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=1:30,tidy=FALSE>>=
system.time(row.sums <- apply(large.matrix, 1, sum))

str(rowSums)  # get list of arguments
# sum the rows and columns
row.sums <- c()
system.time(row.sums <- rowSums(large.matrix))
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Exception Handling}


%%%%%%%%%%%%%%%
\subsection{Exception Conditions: Errors and Warnings}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      \emph{Conditions} are $R$ objects containing information about errors, warnings etc., produced while evaluating expressions,
      \vskip1ex
      The function \texttt{tryCatch()} can be used as a wrapper around functions or expressions, to handle conditions produced when they are evaluated,
      \vskip1ex
      If no condition is produced then \texttt{tryCatch()} just returns the value of the expression,
      \vskip1ex
      If a condition is produced then \texttt{tryCatch()} invokes error and warning \emph{handlers} and executes other expressions to provide information about the condition, 
      \vskip1ex
      If a \emph{handler} is provided to \texttt{tryCatch()} then the error is captured by the \emph{handler}, instead of being broadcast,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
str(tryCatch)  # get arguments of tryCatch()
tryCatch(  # without error handler
  {  # evaluate expressions
    n.val <- 101  # assign
    stop('my error')  # throw error
  }, 
  finally=print(paste("n.val=", n.val))
)  # end tryCatch

tryCatch(  # with error handler
  {  # evaluate expressions
    n.val <- 101  # assign
    stop('my error')  # throw error
  }, 
  error=function(e.cond)  # handler captures error condition
    print(paste("error handler: ", e.cond)),
  finally=print(paste("n.val=", n.val))
)  # end tryCatch
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Exception Handling in Loops}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      The function \texttt{tryCatch()} captures errors, allowing loops to continue after the error condition,
      <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
# apply loop without tryCatch
apply(as.matrix(1:5), 1, function(n.val) {  # anonymous function
    stopifnot(n.val != 3)  # check for error
    cat("(cat) n.val=", n.val)  # broadcast
    paste("(return) n.val=", n.val)  # return value
  }  # end anonymous function
)  # end apply
      @
      Without \texttt{tryCatch()}, the  \texttt{apply()} loop exits without returning any result,
    \column{0.5\textwidth}
      \vspace{-2em}
      <<echo=1:30,tidy=FALSE>>=
# apply loop with tryCatch
apply(as.matrix(1:5), 1, function(n.val) {  # anonymous function
    tryCatch(  # with error handler
      {  # body
        stopifnot(n.val != 3)  # check for error
        cat("(cat) n.val=", n.val)  # broadcast
        paste("(return) n.val=", n.val)  # return value
      },
      error=function(e.cond)  # handler captures error condition
        paste("handler: ", e.cond),
      finally=print(paste("(finally) n.val=", n.val))
    )  # end tryCatch
  }  # end anonymous function
)  # end apply
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Data Munging}


%%%%%%%%%%%%%%%
\subsection{$R$ Scripts}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{sink()} diverts output to a file, or ends the diversion,
      \vskip1ex
      \emph{Conditions} are $R$ objects containing information about errors, warnings etc., produced while evaluating expressions,
      \vskip1ex
      If no condition is produced then \texttt{tryCatch()} just returns the value of the expression,
      \vskip1ex
      If a condition is produced then \texttt{tryCatch()} invokes error and warning \emph{handlers} and executes other expressions to provide information about the condition, 
      \vskip1ex
      If a \emph{handler} is provided to \texttt{tryCatch()} then the error is captured by the \emph{handler}, instead of being broadcast,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
# sink("script.R")  # redirect to script file
# sink()  # Turn redirect off
# source("script.R", echo=TRUE)  # source script
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{\texttt{pdf} Files}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.4\textwidth}
      The function \texttt{sink()} diverts output to a file, or ends the diversion,
      \vskip1ex
      \emph{Conditions} are $R$ objects containing information about errors, warnings etc., produced while evaluating expressions,
      \vskip1ex
      If no condition is produced then \texttt{tryCatch()} just returns the value of the expression,
      \vskip1ex
      If a condition is produced then \texttt{tryCatch()} invokes error and warning \emph{handlers} and executes other expressions to provide information about the condition, 
      \vskip1ex
      If a \emph{handler} is provided to \texttt{tryCatch()} then the error is captured by the \emph{handler}, instead of being broadcast,
    \column{0.6\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE>>=
rm(list=ls())
# pdf(file.cds.plots, width=7, height=11)
# par(mfrow=c(2,1))
# Plot the Variance Profile for a list of symbols, one by one
# Turn PDF writer off
# dev.off()
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\section{Plotting Using Package \texttt{ggplot2}}


%%%%%%%%%%%%%%%
\subsection{Plotting \texttt{zoo} Time Series}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \texttt{ggplot2} is a very popular $R$ package for advanced plotting,
      \vskip1ex
      The function \texttt{autoplot()} creates a \texttt{ggplot2} object,
      \vskip1ex
      The function \texttt{theme()} allows customizing \texttt{ggplot2} objects,
      <<quantlib,echo=3:30,tidy=FALSE,fig.width=6,fig.height=4,fig.show='hide'>>=
rm(list=ls())
set.seed(1121)  # initialize the random number generator
library(zoo)  # load zoo
library(ggplot2)  # load ggplot2
library(scales)  # load scales
# coerce mts object into zoo
zoo.eustx <- as.zoo(EuStockMarkets)
# coerce index into class 'Dates'
index(zoo.eustx) <- as.Date(365*(index(zoo.eustx)-1970))
# create simple ggplot2 in single pane
gg2.zoo <- autoplot(zoo.eustx, main="Eu Stox", 
                    facets=NULL)
# customize ggplot2 using 'theme' function
gg2.zoo + xlab("") + 
  theme(legend.position=c(0.1, 0.5), 
  plot.title=element_text(vjust=-2.0), 
  plot.background=element_blank())

      @
    \column{0.5\textwidth}
      \vspace{-1em}
      \hspace*{-3em}
      \includegraphics[width=0.55\paperwidth,valign=t]{figure/quantlib}
  \end{columns}
\end{block}

\end{frame}

%%%%%%%%%%%%%%%
\section{Regression}


%%%%%%%%%%%%%%%
\subsection{Simple \secname\hskip0.5em Example}
\begin{frame}[fragile,t]{\subsecname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.3\textwidth}
      \verb|datasets| is a base package containing various datasets, for example \verb|EuStockMarkets|,

    \column{0.7\textwidth}
      \vspace{-1em}
        <<echo=2:30,tidy=FALSE,fig.show='hide'>>=
rm(list=ls())
set.seed(1121)  # initialize random number generator
v.xvar <- 0.1*1:30  # independent variable
v.yvar <- 3 + 2*v.xvar + rnorm(30)  # dependent variable plus noise
lm.simp <- lm(v.yvar ~ v.xvar)  # perform regression
summary(lm.simp)  # regression summary
      @
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\begin{frame}[fragile,t]{Plotting a \secname}
\begin{block}{}
  \begin{columns}[T]
    \column{0.5\textwidth}
      \verb|datasets| is a base package containing various datasets, for example \verb|EuStockMarkets|,

        <<simp_reg,echo=2:30,tidy=FALSE,fig.show='hide'>>=
rm(list=ls())
set.seed(1121)  # initialize random number generator
v.xvar <- 0.1*1:30
v.yvar <- 3 + 2*v.xvar + rnorm(30)
lm.simp <- lm(v.yvar ~ v.xvar)  # perform regression
# set plot paramaters - margins and font scale
par(oma=c(1, 1, 1, 1))  # set outer margins
par(mgp=c(2, 1, 0))  # axis title and labels
par(mar=c(5, 3, 1, 1), cex.lab=0.8, 
    cex.axis=0.8, cex.main=0.8, cex.sub=0.5)
plot(v.yvar ~ v.xvar)  # plot scatterplot
title(main="Simple Regression", line=-1)
abline(lm.simp, col="red")  # add reg line
      @

    \column{0.5\textwidth}
      \vspace{-1em}
      \includegraphics[width=0.5\paperwidth,valign=t]{figure/simp_reg}
  \end{columns}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Homework Assignment}
\begin{frame}[t]{\subsecname}

\begin{block}{Required}
  \begin{itemize}
    \item Create a function for calculating the kurtosis of a time series of returns,
    \item Using this function calculate the kurtosis of DAX returns, and of t-distribution returns with four degrees of freedom (use the same number of data points in both cases),
    \item Plot the probability density of DAX returns together with t-distribution returns with four degrees of freedom on a single plot,
  \end{itemize}
\end{block}
\pause

\begin{block}{Recommended}
  \begin{itemize}
    \item Read chapters 4, 5, 10: \fullcite{website:rintro}
  \end{itemize}
\end{block}

\end{frame}


%%%%%%%%%%%%%%%
\subsection{Additional Reading}
\begin{frame}[t]{\subsecname}

Download $R$ Interpreter from $CRAN$ (Comprehensive $R$ Archive Network)\\
\hskip1em\url{http://cran.us.r-project.org}\\
\vskip4ex
Download $RStudio$ IDE (Integrated Development Environment)\\
\hskip1em\url{http://www.rstudio.com/ide}\\
\vskip4ex

\end{frame}


\end{document}
